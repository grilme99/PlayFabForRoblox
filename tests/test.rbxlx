<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">TS</string>
        <string name="Source">local Settings = require(script.PlayFabSettings);

local PlayFabAdmin = require(script.PlayFabAdmin);
local PlayFabClient = require(script.PlayFabClient);
local PlayFabMatchmaker = require(script.PlayFabMatchmaker);
local PlayFabServer = require(script.PlayFabServer);
local PlayFabAuthentication = require(script.PlayFabAuthentication);
local PlayFabCloudScript = require(script.PlayFabCloudScript);
local PlayFabData = require(script.PlayFabData);
local PlayFabEvents = require(script.PlayFabEvents);
local PlayFabExperimentation = require(script.PlayFabExperimentation);
local PlayFabInsights = require(script.PlayFabInsights);
local PlayFabGroups = require(script.PlayFabGroups);
local PlayFabLocalization = require(script.PlayFabLocalization);
local PlayFabMultiplayer = require(script.PlayFabMultiplayer);
local PlayFabProfiles = require(script.PlayFabProfiles);

return {
    PlayFabAdmin = PlayFabAdmin,
    PlayFabClient = PlayFabClient,
    PlayFabMatchmaker = PlayFabMatchmaker,
    PlayFabServer = PlayFabServer,
    PlayFabAuthentication = PlayFabAuthentication,
    PlayFabCloudScript = PlayFabCloudScript,
    PlayFabData = PlayFabData,
    PlayFabEvents = PlayFabEvents,
    PlayFabExperimentation = PlayFabExperimentation,
    PlayFabInsights = PlayFabInsights,
    PlayFabGroups = PlayFabGroups,
    PlayFabLocalization = PlayFabLocalization,
    PlayFabMultiplayer = PlayFabMultiplayer,
    PlayFabProfiles = PlayFabProfiles,
    Settings = Settings.settings
};</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">IPlayFabHttps</string>
          <string name="Source">local HttpService = game:GetService("HttpService")
local Promise = require(script.Parent.Promise)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local IPlayFabHttps = {}

local function GetFullUrl(urlPath)
	local fullUrl = "https://" .. PlayFabSettings.settings.titleId .. PlayFabSettings.settings.productionUrl .. urlPath
	local getParams = PlayFabSettings._internalSettings.requestGetParams
	local firstParam = true
	for key, value in pairs(getParams) do
		if firstParam then
			fullUrl ..= "?"
			firstParam = false
		else
			fullUrl ..= "&amp;"
		end

		fullUrl ..= key .. "=" .. value
	end

	return fullUrl
end

function IPlayFabHttps.MakePlayFabApiCall(path, requestBody, authKey, authValue, onSuccess, onError)
    local fullUrl = GetFullUrl(path)
    local encodedBody = HttpService:JSONEncode(requestBody)
    local headers = {
        ["X-ReportErrorAsSuccess"] = "true",
        ["X-PlayFabSDK"] = PlayFabSettings._internalSettings.sdkVersionString,
        ["Content-Type"] = "application/json",
    }

    if authKey and authValue ~= "" and authValue then
        headers[authKey] = authValue
    end

    local success, response = pcall(HttpService.RequestAsync, HttpService, {
        Url = fullUrl,
        Method = "POST",
        Headers = headers,
        Body = encodedBody,
    })

    if success then
        if response.Success then
            local responseBody = HttpService:JSONDecode(response.Body)
            if responseBody and responseBody.code == 200 and responseBody.data then
                onSuccess(responseBody.data)
            else
                onError(response)
            end
        else
            onError(response)
        end
    else
        onError(tostring(response))
    end
end

return IPlayFabHttps</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">PlayFabAdmin</string>
          <string name="Source"><![CDATA[-- PlayFab Admin API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabAdminApi = {
    settings = PlayFabSettings.settings
}

--[[
    Abort an ongoing task instance.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/aborttaskinstance
--]]
function PlayFabAdminApi:AbortTaskInstance(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/AbortTaskInstance", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Update news item to include localized version
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/addlocalizednews
--]]
function PlayFabAdminApi:AddLocalizedNews(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/AddLocalizedNews", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds a new news item to the title's news feed
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/addnews
--]]
function PlayFabAdminApi:AddNews(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/AddNews", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds a given tag to a player profile. The tag's namespace is automatically generated based on the source of the tag.
    https://docs.microsoft.com/rest/api/playfab/admin/playstream/addplayertag
--]]
function PlayFabAdminApi:AddPlayerTag(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/AddPlayerTag", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds the game server executable specified (previously uploaded - see GetServerBuildUploadUrl) to the set of those a
    client is permitted to request in a call to StartGame
    https://docs.microsoft.com/rest/api/playfab/admin/custom-server-management/addserverbuild
--]]
function PlayFabAdminApi:AddServerBuild(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/AddServerBuild", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Increments the specified virtual currency by the stated amount
    https://docs.microsoft.com/rest/api/playfab/admin/player-item-management/adduservirtualcurrency
--]]
function PlayFabAdminApi:AddUserVirtualCurrency(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/AddUserVirtualCurrency", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds one or more virtual currencies to the set defined for the title. Virtual Currencies have a maximum value of
    2,147,483,647 when granted to a player. Any value over that will be discarded.
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/addvirtualcurrencytypes
--]]
function PlayFabAdminApi:AddVirtualCurrencyTypes(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/AddVirtualCurrencyTypes", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Bans users by PlayFab ID with optional IP address, or MAC address for the provided game.
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/banusers
--]]
function PlayFabAdminApi:BanUsers(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/BanUsers", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Checks the global count for the limited edition item.
    https://docs.microsoft.com/rest/api/playfab/admin/player-item-management/checklimitededitionitemavailability
--]]
function PlayFabAdminApi:CheckLimitedEditionItemAvailability(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/CheckLimitedEditionItemAvailability", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Create an ActionsOnPlayersInSegment task, which iterates through all players in a segment to execute action.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/createactionsonplayersinsegmenttask
--]]
function PlayFabAdminApi:CreateActionsOnPlayersInSegmentTask(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/CreateActionsOnPlayersInSegmentTask", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Create a CloudScript task, which can run a CloudScript on a schedule.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/createcloudscripttask
--]]
function PlayFabAdminApi:CreateCloudScriptTask(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/CreateCloudScriptTask", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Create a Insights Scheduled Scaling task, which can scale Insights Performance Units on a schedule
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/createinsightsscheduledscalingtask
--]]
function PlayFabAdminApi:CreateInsightsScheduledScalingTask(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/CreateInsightsScheduledScalingTask", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Registers a relationship between a title and an Open ID Connect provider.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/createopenidconnection
--]]
function PlayFabAdminApi:CreateOpenIdConnection(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/CreateOpenIdConnection", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Creates a new Player Shared Secret Key. It may take up to 5 minutes for this key to become generally available after
    this API returns.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/createplayersharedsecret
--]]
function PlayFabAdminApi:CreatePlayerSharedSecret(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/CreatePlayerSharedSecret", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds a new player statistic configuration to the title, optionally allowing the developer to specify a reset interval
    and an aggregation method.
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/createplayerstatisticdefinition
--]]
function PlayFabAdminApi:CreatePlayerStatisticDefinition(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/CreatePlayerStatisticDefinition", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Delete a content file from the title. When deleting a file that does not exist, it returns success.
    https://docs.microsoft.com/rest/api/playfab/admin/content/deletecontent
--]]
function PlayFabAdminApi:DeleteContent(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeleteContent", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes a master player account entirely from all titles and deletes all associated data
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/deletemasterplayeraccount
--]]
function PlayFabAdminApi:DeleteMasterPlayerAccount(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeleteMasterPlayerAccount", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes a relationship between a title and an OpenID Connect provider.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/deleteopenidconnection
--]]
function PlayFabAdminApi:DeleteOpenIdConnection(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeleteOpenIdConnection", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes a user's player account from a title and deletes all associated data
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/deleteplayer
--]]
function PlayFabAdminApi:DeletePlayer(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeletePlayer", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Deletes an existing Player Shared Secret Key. It may take up to 5 minutes for this delete to be reflected after this API
    returns.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/deleteplayersharedsecret
--]]
function PlayFabAdminApi:DeletePlayerSharedSecret(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeletePlayerSharedSecret", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Deletes an existing virtual item store
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/deletestore
--]]
function PlayFabAdminApi:DeleteStore(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeleteStore", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Delete a task.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/deletetask
--]]
function PlayFabAdminApi:DeleteTask(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeleteTask", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Permanently deletes a title and all associated configuration
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/deletetitle
--]]
function PlayFabAdminApi:DeleteTitle(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeleteTitle", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Deletes a specified set of title data overrides.
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/deletetitledataoverride
--]]
function PlayFabAdminApi:DeleteTitleDataOverride(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/DeleteTitleDataOverride", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Exports all associated data of a master player account
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/exportmasterplayerdata
--]]
function PlayFabAdminApi:ExportMasterPlayerData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ExportMasterPlayerData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Get information about a ActionsOnPlayersInSegment task instance.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/getactionsonplayersinsegmenttaskinstance
--]]
function PlayFabAdminApi:GetActionsOnPlayersInSegmentTaskInstance(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetActionsOnPlayersInSegmentTaskInstance", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves an array of player segment definitions. Results from this can be used in subsequent API calls such as
    GetPlayersInSegment which requires a Segment ID. While segment names can change the ID for that segment will not change.
    https://docs.microsoft.com/rest/api/playfab/admin/playstream/getallsegments
--]]
function PlayFabAdminApi:GetAllSegments(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetAllSegments", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the specified version of the title's catalog of virtual goods, including all defined properties
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/getcatalogitems
--]]
function PlayFabAdminApi:GetCatalogItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetCatalogItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Gets the contents and information of a specific Cloud Script revision.
    https://docs.microsoft.com/rest/api/playfab/admin/server-side-cloud-script/getcloudscriptrevision
--]]
function PlayFabAdminApi:GetCloudScriptRevision(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetCloudScriptRevision", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Get detail information about a CloudScript task instance.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/getcloudscripttaskinstance
--]]
function PlayFabAdminApi:GetCloudScriptTaskInstance(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetCloudScriptTaskInstance", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Lists all the current cloud script versions. For each version, information about the current published and latest
    revisions is also listed.
    https://docs.microsoft.com/rest/api/playfab/admin/server-side-cloud-script/getcloudscriptversions
--]]
function PlayFabAdminApi:GetCloudScriptVersions(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetCloudScriptVersions", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    List all contents of the title and get statistics such as size
    https://docs.microsoft.com/rest/api/playfab/admin/content/getcontentlist
--]]
function PlayFabAdminApi:GetContentList(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetContentList", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the pre-signed URL for uploading a content file. A subsequent HTTP PUT to the returned URL uploads the
    content. Also, please be aware that the Content service is specifically PlayFab's CDN offering, for which standard CDN
    rates apply.
    https://docs.microsoft.com/rest/api/playfab/admin/content/getcontentuploadurl
--]]
function PlayFabAdminApi:GetContentUploadUrl(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetContentUploadUrl", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves a download URL for the requested report
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getdatareport
--]]
function PlayFabAdminApi:GetDataReport(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetDataReport", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the details for a specific completed session, including links to standard out and standard error logs
    https://docs.microsoft.com/rest/api/playfab/admin/matchmaking/getmatchmakergameinfo
--]]
function PlayFabAdminApi:GetMatchmakerGameInfo(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetMatchmakerGameInfo", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the details of defined game modes for the specified game server executable
    https://docs.microsoft.com/rest/api/playfab/admin/matchmaking/getmatchmakergamemodes
--]]
function PlayFabAdminApi:GetMatchmakerGameModes(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetMatchmakerGameModes", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Get the list of titles that the player has played
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/getplayedtitlelist
--]]
function PlayFabAdminApi:GetPlayedTitleList(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayedTitleList", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Gets a player's ID from an auth token.
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/getplayeridfromauthtoken
--]]
function PlayFabAdminApi:GetPlayerIdFromAuthToken(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayerIdFromAuthToken", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the player's profile
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/getplayerprofile
--]]
function PlayFabAdminApi:GetPlayerProfile(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayerProfile", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    List all segments that a player currently belongs to at this moment in time.
    https://docs.microsoft.com/rest/api/playfab/admin/playstream/getplayersegments
--]]
function PlayFabAdminApi:GetPlayerSegments(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayerSegments", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Returns all Player Shared Secret Keys including disabled and expired.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/getplayersharedsecrets
--]]
function PlayFabAdminApi:GetPlayerSharedSecrets(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayerSharedSecrets", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Allows for paging through all players in a given segment. This API creates a snapshot of all player profiles that match
    the segment definition at the time of its creation and lives through the Total Seconds to Live, refreshing its life span
    on each subsequent use of the Continuation Token. Profiles that change during the course of paging will not be reflected
    in the results. AB Test segments are currently not supported by this operation. NOTE: This API is limited to being
    called 30 times in one minute. You will be returned an error if you exceed this threshold.
    https://docs.microsoft.com/rest/api/playfab/admin/playstream/getplayersinsegment
--]]
function PlayFabAdminApi:GetPlayersInSegment(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayersInSegment", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the configuration information for all player statistics defined in the title, regardless of whether they have
    a reset interval.
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getplayerstatisticdefinitions
--]]
function PlayFabAdminApi:GetPlayerStatisticDefinitions(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayerStatisticDefinitions", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the information on the available versions of the specified statistic.
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getplayerstatisticversions
--]]
function PlayFabAdminApi:GetPlayerStatisticVersions(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayerStatisticVersions", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Get all tags with a given Namespace (optional) from a player profile.
    https://docs.microsoft.com/rest/api/playfab/admin/playstream/getplayertags
--]]
function PlayFabAdminApi:GetPlayerTags(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPlayerTags", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Gets the requested policy.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/getpolicy
--]]
function PlayFabAdminApi:GetPolicy(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPolicy", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the key-value store of custom publisher settings
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/getpublisherdata
--]]
function PlayFabAdminApi:GetPublisherData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetPublisherData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the random drop table configuration for the title
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/getrandomresulttables
--]]
function PlayFabAdminApi:GetRandomResultTables(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetRandomResultTables", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the build details for the specified game server executable
    https://docs.microsoft.com/rest/api/playfab/admin/custom-server-management/getserverbuildinfo
--]]
function PlayFabAdminApi:GetServerBuildInfo(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetServerBuildInfo", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the pre-authorized URL for uploading a game server package containing a build (does not enable the build for
    use - see AddServerBuild)
    https://docs.microsoft.com/rest/api/playfab/admin/custom-server-management/getserverbuilduploadurl
--]]
function PlayFabAdminApi:GetServerBuildUploadUrl(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetServerBuildUploadUrl", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the set of items defined for the specified store, including all prices defined
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/getstoreitems
--]]
function PlayFabAdminApi:GetStoreItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetStoreItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Query for task instances by task, status, or time range.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/gettaskinstances
--]]
function PlayFabAdminApi:GetTaskInstances(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetTaskInstances", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Get definition information on a specified task or all tasks within a title.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/gettasks
--]]
function PlayFabAdminApi:GetTasks(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetTasks", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the key-value store of custom title settings which can be read by the client
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/gettitledata
--]]
function PlayFabAdminApi:GetTitleData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetTitleData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the key-value store of custom title settings which cannot be read by the client
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/gettitleinternaldata
--]]
function PlayFabAdminApi:GetTitleInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetTitleInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the relevant details for a specified user, based upon a match against a supplied unique identifier
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/getuseraccountinfo
--]]
function PlayFabAdminApi:GetUserAccountInfo(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserAccountInfo", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Gets all bans for a user.
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/getuserbans
--]]
function PlayFabAdminApi:GetUserBans(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserBans", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getuserdata
--]]
function PlayFabAdminApi:GetUserData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getuserinternaldata
--]]
function PlayFabAdminApi:GetUserInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the specified user's current inventory of virtual goods
    https://docs.microsoft.com/rest/api/playfab/admin/player-item-management/getuserinventory
--]]
function PlayFabAdminApi:GetUserInventory(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserInventory", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the publisher-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getuserpublisherdata
--]]
function PlayFabAdminApi:GetUserPublisherData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserPublisherData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the publisher-specific custom data for the user which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getuserpublisherinternaldata
--]]
function PlayFabAdminApi:GetUserPublisherInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserPublisherInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the publisher-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getuserpublisherreadonlydata
--]]
function PlayFabAdminApi:GetUserPublisherReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserPublisherReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/getuserreadonlydata
--]]
function PlayFabAdminApi:GetUserReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GetUserReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds the specified items to the specified user inventories
    https://docs.microsoft.com/rest/api/playfab/admin/player-item-management/grantitemstousers
--]]
function PlayFabAdminApi:GrantItemsToUsers(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/GrantItemsToUsers", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Increases the global count for the given scarce resource.
    https://docs.microsoft.com/rest/api/playfab/admin/player-item-management/incrementlimitededitionitemavailability
--]]
function PlayFabAdminApi:IncrementLimitedEditionItemAvailability(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/IncrementLimitedEditionItemAvailability", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Resets the indicated statistic, removing all player entries for it and backing up the old values.
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/incrementplayerstatisticversion
--]]
function PlayFabAdminApi:IncrementPlayerStatisticVersion(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/IncrementPlayerStatisticVersion", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves a list of all Open ID Connect providers registered to a title.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/listopenidconnection
--]]
function PlayFabAdminApi:ListOpenIdConnection(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ListOpenIdConnection", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the build details for all game server executables which are currently defined for the title
    https://docs.microsoft.com/rest/api/playfab/admin/custom-server-management/listserverbuilds
--]]
function PlayFabAdminApi:ListServerBuilds(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ListServerBuilds", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retuns the list of all defined virtual currencies for the title
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/listvirtualcurrencytypes
--]]
function PlayFabAdminApi:ListVirtualCurrencyTypes(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ListVirtualCurrencyTypes", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the game server mode details for the specified game server executable
    https://docs.microsoft.com/rest/api/playfab/admin/matchmaking/modifymatchmakergamemodes
--]]
function PlayFabAdminApi:ModifyMatchmakerGameModes(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ModifyMatchmakerGameModes", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the build details for the specified game server executable
    https://docs.microsoft.com/rest/api/playfab/admin/custom-server-management/modifyserverbuild
--]]
function PlayFabAdminApi:ModifyServerBuild(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ModifyServerBuild", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Attempts to process an order refund through the original real money payment provider.
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/refundpurchase
--]]
function PlayFabAdminApi:RefundPurchase(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RefundPurchase", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Remove a given tag from a player profile. The tag's namespace is automatically generated based on the source of the tag.
    https://docs.microsoft.com/rest/api/playfab/admin/playstream/removeplayertag
--]]
function PlayFabAdminApi:RemovePlayerTag(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RemovePlayerTag", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes the game server executable specified from the set of those a client is permitted to request in a call to
    StartGame
    https://docs.microsoft.com/rest/api/playfab/admin/custom-server-management/removeserverbuild
--]]
function PlayFabAdminApi:RemoveServerBuild(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RemoveServerBuild", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes one or more virtual currencies from the set defined for the title.
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/removevirtualcurrencytypes
--]]
function PlayFabAdminApi:RemoveVirtualCurrencyTypes(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RemoveVirtualCurrencyTypes", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Completely removes all statistics for the specified character, for the current game
    https://docs.microsoft.com/rest/api/playfab/admin/characters/resetcharacterstatistics
--]]
function PlayFabAdminApi:ResetCharacterStatistics(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ResetCharacterStatistics", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Reset a player's password for a given title.
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/resetpassword
--]]
function PlayFabAdminApi:ResetPassword(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ResetPassword", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Completely removes all statistics for the specified user, for the current game
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/resetuserstatistics
--]]
function PlayFabAdminApi:ResetUserStatistics(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ResetUserStatistics", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Attempts to resolve a dispute with the original order's payment provider.
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/resolvepurchasedispute
--]]
function PlayFabAdminApi:ResolvePurchaseDispute(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/ResolvePurchaseDispute", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Revoke all active bans for a user.
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/revokeallbansforuser
--]]
function PlayFabAdminApi:RevokeAllBansForUser(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RevokeAllBansForUser", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Revoke all active bans specified with BanId.
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/revokebans
--]]
function PlayFabAdminApi:RevokeBans(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RevokeBans", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Revokes access to an item in a user's inventory
    https://docs.microsoft.com/rest/api/playfab/admin/player-item-management/revokeinventoryitem
--]]
function PlayFabAdminApi:RevokeInventoryItem(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RevokeInventoryItem", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Revokes access for up to 25 items across multiple users and characters.
    https://docs.microsoft.com/rest/api/playfab/admin/player-item-management/revokeinventoryitems
--]]
function PlayFabAdminApi:RevokeInventoryItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RevokeInventoryItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Run a task immediately regardless of its schedule.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/runtask
--]]
function PlayFabAdminApi:RunTask(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/RunTask", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Forces an email to be sent to the registered email address for the user's account, with a link allowing the user to
    change the password.If an account recovery email template ID is provided, an email using the custom email template will
    be used.
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/sendaccountrecoveryemail
--]]
function PlayFabAdminApi:SendAccountRecoveryEmail(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SendAccountRecoveryEmail", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Creates the catalog configuration of all virtual goods for the specified catalog version
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/setcatalogitems
--]]
function PlayFabAdminApi:SetCatalogItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetCatalogItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sets or resets the player's secret. Player secrets are used to sign API requests.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/setplayersecret
--]]
function PlayFabAdminApi:SetPlayerSecret(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetPlayerSecret", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sets the currently published revision of a title Cloud Script
    https://docs.microsoft.com/rest/api/playfab/admin/server-side-cloud-script/setpublishedrevision
--]]
function PlayFabAdminApi:SetPublishedRevision(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetPublishedRevision", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the key-value store of custom publisher settings
    https://docs.microsoft.com/rest/api/playfab/admin/shared-group-data/setpublisherdata
--]]
function PlayFabAdminApi:SetPublisherData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetPublisherData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sets all the items in one virtual store
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/setstoreitems
--]]
function PlayFabAdminApi:SetStoreItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetStoreItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Creates and updates the key-value store of custom title settings which can be read by the client
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/settitledata
--]]
function PlayFabAdminApi:SetTitleData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetTitleData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Set and delete key-value pairs in a title data override instance.
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/settitledataandoverrides
--]]
function PlayFabAdminApi:SetTitleDataAndOverrides(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetTitleDataAndOverrides", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the key-value store of custom title settings which cannot be read by the client
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/settitleinternaldata
--]]
function PlayFabAdminApi:SetTitleInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetTitleInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sets the Amazon Resource Name (ARN) for iOS and Android push notifications. Documentation on the exact restrictions can
    be found at: http://docs.aws.amazon.com/sns/latest/api/API_CreatePlatformApplication.html. Currently, Amazon device
    Messaging is not supported.
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/setuppushnotification
--]]
function PlayFabAdminApi:SetupPushNotification(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SetupPushNotification", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Decrements the specified virtual currency by the stated amount
    https://docs.microsoft.com/rest/api/playfab/admin/player-item-management/subtractuservirtualcurrency
--]]
function PlayFabAdminApi:SubtractUserVirtualCurrency(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/SubtractUserVirtualCurrency", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates information of a list of existing bans specified with Ban Ids.
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/updatebans
--]]
function PlayFabAdminApi:UpdateBans(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateBans", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the catalog configuration for virtual goods in the specified catalog version
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/updatecatalogitems
--]]
function PlayFabAdminApi:UpdateCatalogItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateCatalogItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Creates a new Cloud Script revision and uploads source code to it. Note that at this time, only one file should be
    submitted in the revision.
    https://docs.microsoft.com/rest/api/playfab/admin/server-side-cloud-script/updatecloudscript
--]]
function PlayFabAdminApi:UpdateCloudScript(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateCloudScript", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Modifies data and credentials for an existing relationship between a title and an Open ID Connect provider
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/updateopenidconnection
--]]
function PlayFabAdminApi:UpdateOpenIdConnection(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateOpenIdConnection", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates a existing Player Shared Secret Key. It may take up to 5 minutes for this update to become generally available
    after this API returns.
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/updateplayersharedsecret
--]]
function PlayFabAdminApi:UpdatePlayerSharedSecret(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdatePlayerSharedSecret", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates a player statistic configuration for the title, optionally allowing the developer to specify a reset interval.
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/updateplayerstatisticdefinition
--]]
function PlayFabAdminApi:UpdatePlayerStatisticDefinition(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdatePlayerStatisticDefinition", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Changes a policy for a title
    https://docs.microsoft.com/rest/api/playfab/admin/authentication/updatepolicy
--]]
function PlayFabAdminApi:UpdatePolicy(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdatePolicy", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the random drop table configuration for the title
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/updaterandomresulttables
--]]
function PlayFabAdminApi:UpdateRandomResultTables(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateRandomResultTables", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates an existing virtual item store with new or modified items
    https://docs.microsoft.com/rest/api/playfab/admin/title-wide-data-management/updatestoreitems
--]]
function PlayFabAdminApi:UpdateStoreItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateStoreItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Update an existing task.
    https://docs.microsoft.com/rest/api/playfab/admin/scheduledtask/updatetask
--]]
function PlayFabAdminApi:UpdateTask(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateTask", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/updateuserdata
--]]
function PlayFabAdminApi:UpdateUserData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateUserData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/updateuserinternaldata
--]]
function PlayFabAdminApi:UpdateUserInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateUserInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the publisher-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/updateuserpublisherdata
--]]
function PlayFabAdminApi:UpdateUserPublisherData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateUserPublisherData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the publisher-specific custom data for the user which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/updateuserpublisherinternaldata
--]]
function PlayFabAdminApi:UpdateUserPublisherInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateUserPublisherInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the publisher-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/updateuserpublisherreadonlydata
--]]
function PlayFabAdminApi:UpdateUserPublisherReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateUserPublisherReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/admin/player-data-management/updateuserreadonlydata
--]]
function PlayFabAdminApi:UpdateUserReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateUserReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title specific display name for a user
    https://docs.microsoft.com/rest/api/playfab/admin/account-management/updateusertitledisplayname
--]]
function PlayFabAdminApi:UpdateUserTitleDisplayName(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Admin/UpdateUserTitleDisplayName", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

return PlayFabAdminApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">PlayFabAuthentication</string>
          <string name="Source"><![CDATA[-- PlayFab Authentication API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabAuthenticationApi = {
    settings = PlayFabSettings.settings
}

--[[
    Method to exchange a legacy AuthenticationTicket or title SecretKey for an Entity Token or to refresh a still valid
    Entity Token.
    https://docs.microsoft.com/rest/api/playfab/authentication/authentication/getentitytoken
--]]
function PlayFabAuthenticationApi:GetEntityToken(request)
    return Promise.new(function(resolve, reject)
         local authKey = nil
     local authValue = nil
     if (PlayFabSettings._internalSettings.entityToken) then
         authKey = "X-EntityToken"
         authValue = PlayFabSettings._internalSettings.entityToken
     end
     if (PlayFabSettings._internalSettings.sessionTicket) then
         authKey = "X-Authorization"
         authValue = PlayFabSettings._internalSettings.sessionTicket
     end
     if (PlayFabSettings.settings.devSecretKey) then
         authKey = "X-SecretKey"
         authValue = PlayFabSettings.settings.devSecretKey
     end
        IPlayFabHttps.MakePlayFabApiCall("/Authentication/GetEntityToken", request or {}, authKey, authValue, resolve, reject)
    end)
end

--[[
    Method for a server to validate a client provided EntityToken. Only callable by the title entity.
    https://docs.microsoft.com/rest/api/playfab/authentication/authentication/validateentitytoken
--]]
function PlayFabAuthenticationApi:ValidateEntityToken(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Authentication/ValidateEntityToken", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabAuthenticationApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">PlayFabClient</string>
          <string name="Source"><![CDATA[-- PlayFab Client API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabClientApi = {
    settings = PlayFabSettings.settings
}

--[[
    Accepts an open trade (one that has not yet been accepted or cancelled), if the locally signed-in player is in the
    allowed player list for the trade, or it is open to all players. If the call is successful, the offered and accepted
    items will be swapped between the two players' inventories.
    https://docs.microsoft.com/rest/api/playfab/client/trading/accepttrade
--]]
function PlayFabClientApi:AcceptTrade(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AcceptTrade", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Adds the PlayFab user, based upon a match against a supplied unique identifier, to the friend list of the local user. At
    least one of FriendPlayFabId,FriendUsername,FriendEmail, or FriendTitleDisplayName should be initialized.
    https://docs.microsoft.com/rest/api/playfab/client/friend-list-management/addfriend
--]]
function PlayFabClientApi:AddFriend(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AddFriend", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Adds the specified generic service identifier to the player's PlayFab account. This is designed to allow for a PlayFab
    ID lookup of any arbitrary service identifier a title wants to add. This identifier should never be used as
    authentication credentials, as the intent is that it is easily accessible by other players.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/addgenericid
--]]
function PlayFabClientApi:AddGenericID(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AddGenericID", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Adds or updates a contact email to the player's profile.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/addorupdatecontactemail
--]]
function PlayFabClientApi:AddOrUpdateContactEmail(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AddOrUpdateContactEmail", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Adds users to the set of those able to update both the shared data, as well as the set of users in the group. Only users
    in the group can add new members. Shared Groups are designed for sharing data between a very small number of players,
    please see our guide: https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/client/shared-group-data/addsharedgroupmembers
--]]
function PlayFabClientApi:AddSharedGroupMembers(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AddSharedGroupMembers", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Adds playfab username/password auth to an existing account created via an anonymous auth method, e.g. automatic device
    ID login.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/addusernamepassword
--]]
function PlayFabClientApi:AddUsernamePassword(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AddUsernamePassword", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Increments the user's balance of the specified virtual currency by the stated amount
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/adduservirtualcurrency
--]]
function PlayFabClientApi:AddUserVirtualCurrency(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AddUserVirtualCurrency", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Registers the Android device to receive push notifications
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/androiddevicepushnotificationregistration
--]]
function PlayFabClientApi:AndroidDevicePushNotificationRegistration(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AndroidDevicePushNotificationRegistration", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Attributes an install for advertisment.
    https://docs.microsoft.com/rest/api/playfab/client/advertising/attributeinstall
--]]
function PlayFabClientApi:AttributeInstall(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/AttributeInstall", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Cancels an open trade (one that has not yet been accepted or cancelled). Note that only the player who created the trade
    can cancel it via this API call, to prevent griefing of the trade system (cancelling trades in order to prevent other
    players from accepting them, for trades that can be claimed by more than one player).
    https://docs.microsoft.com/rest/api/playfab/client/trading/canceltrade
--]]
function PlayFabClientApi:CancelTrade(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/CancelTrade", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Confirms with the payment provider that the purchase was approved (if applicable) and adjusts inventory and virtual
    currency balances as appropriate
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/confirmpurchase
--]]
function PlayFabClientApi:ConfirmPurchase(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ConfirmPurchase", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Consume uses of a consumable item. When all uses are consumed, it will be removed from the player's inventory.
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/consumeitem
--]]
function PlayFabClientApi:ConsumeItem(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ConsumeItem", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Checks for any new consumable entitlements. If any are found, they are consumed and added as PlayFab items
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/consumepsnentitlements
--]]
function PlayFabClientApi:ConsumePSNEntitlements(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ConsumePSNEntitlements", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Grants the player's current entitlements from Xbox Live, consuming all availble items in Xbox and granting them to the
    player's PlayFab inventory. This call is idempotent and will not grant previously granted items to the player.
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/consumexboxentitlements
--]]
function PlayFabClientApi:ConsumeXboxEntitlements(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ConsumeXboxEntitlements", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Requests the creation of a shared group object, containing key/value pairs which may be updated by all members of the
    group. Upon creation, the current user will be the only member of the group. Shared Groups are designed for sharing data
    between a very small number of players, please see our guide:
    https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/client/shared-group-data/createsharedgroup
--]]
function PlayFabClientApi:CreateSharedGroup(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/CreateSharedGroup", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Executes a CloudScript function, with the 'currentPlayerId' set to the PlayFab ID of the authenticated player.
    https://docs.microsoft.com/rest/api/playfab/client/server-side-cloud-script/executecloudscript
--]]
function PlayFabClientApi:ExecuteCloudScript(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ExecuteCloudScript", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the user's PlayFab account details
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getaccountinfo
--]]
function PlayFabClientApi:GetAccountInfo(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetAccountInfo", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Returns a list of ad placements and a reward for each
    https://docs.microsoft.com/rest/api/playfab/client/advertising/getadplacements
--]]
function PlayFabClientApi:GetAdPlacements(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetAdPlacements", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Lists all of the characters that belong to a specific user. CharacterIds are not globally unique; characterId must be
    evaluated with the parent PlayFabId to guarantee uniqueness.
    https://docs.microsoft.com/rest/api/playfab/client/characters/getalluserscharacters
--]]
function PlayFabClientApi:GetAllUsersCharacters(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetAllUsersCharacters", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the specified version of the title's catalog of virtual goods, including all defined properties
    https://docs.microsoft.com/rest/api/playfab/client/title-wide-data-management/getcatalogitems
--]]
function PlayFabClientApi:GetCatalogItems(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetCatalogItems", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the character which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/client/character-data/getcharacterdata
--]]
function PlayFabClientApi:GetCharacterData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetCharacterData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the specified character's current inventory of virtual goods
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/getcharacterinventory
--]]
function PlayFabClientApi:GetCharacterInventory(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetCharacterInventory", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked characters for the given statistic, starting from the indicated point in the leaderboard
    https://docs.microsoft.com/rest/api/playfab/client/characters/getcharacterleaderboard
--]]
function PlayFabClientApi:GetCharacterLeaderboard(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetCharacterLeaderboard", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the character which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/client/character-data/getcharacterreadonlydata
--]]
function PlayFabClientApi:GetCharacterReadOnlyData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetCharacterReadOnlyData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the details of all title-specific statistics for the user
    https://docs.microsoft.com/rest/api/playfab/client/characters/getcharacterstatistics
--]]
function PlayFabClientApi:GetCharacterStatistics(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetCharacterStatistics", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    This API retrieves a pre-signed URL for accessing a content file for the title. A subsequent HTTP GET to the returned
    URL will attempt to download the content. A HEAD query to the returned URL will attempt to retrieve the metadata of the
    content. Note that a successful result does not guarantee the existence of this content - if it has not been uploaded,
    the query to retrieve the data will fail. See this post for more information:
    https://community.playfab.com/hc/community/posts/205469488-How-to-upload-files-to-PlayFab-s-Content-Service. Also,
    please be aware that the Content service is specifically PlayFab's CDN offering, for which standard CDN rates apply.
    https://docs.microsoft.com/rest/api/playfab/client/content/getcontentdownloadurl
--]]
function PlayFabClientApi:GetContentDownloadUrl(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetContentDownloadUrl", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Get details about all current running game servers matching the given parameters.
    https://docs.microsoft.com/rest/api/playfab/client/matchmaking/getcurrentgames
--]]
function PlayFabClientApi:GetCurrentGames(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetCurrentGames", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked friends of the current player for the given statistic, starting from the indicated point in
    the leaderboard
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getfriendleaderboard
--]]
function PlayFabClientApi:GetFriendLeaderboard(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetFriendLeaderboard", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked friends of the current player for the given statistic, centered on the requested PlayFab
    user. If PlayFabId is empty or null will return currently logged in user.
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getfriendleaderboardaroundplayer
--]]
function PlayFabClientApi:GetFriendLeaderboardAroundPlayer(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetFriendLeaderboardAroundPlayer", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the current friend list for the local user, constrained to users who have PlayFab accounts. Friends from
    linked accounts (Facebook, Steam) are also included. You may optionally exclude some linked services' friends.
    https://docs.microsoft.com/rest/api/playfab/client/friend-list-management/getfriendslist
--]]
function PlayFabClientApi:GetFriendsList(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetFriendsList", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Get details about the regions hosting game servers matching the given parameters.
    https://docs.microsoft.com/rest/api/playfab/client/matchmaking/getgameserverregions
--]]
function PlayFabClientApi:GetGameServerRegions(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetGameServerRegions", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked users for the given statistic, starting from the indicated point in the leaderboard
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getleaderboard
--]]
function PlayFabClientApi:GetLeaderboard(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetLeaderboard", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked characters for the given statistic, centered on the requested Character ID
    https://docs.microsoft.com/rest/api/playfab/client/characters/getleaderboardaroundcharacter
--]]
function PlayFabClientApi:GetLeaderboardAroundCharacter(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetLeaderboardAroundCharacter", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked users for the given statistic, centered on the requested player. If PlayFabId is empty or
    null will return currently logged in user.
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getleaderboardaroundplayer
--]]
function PlayFabClientApi:GetLeaderboardAroundPlayer(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetLeaderboardAroundPlayer", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves a list of all of the user's characters for the given statistic.
    https://docs.microsoft.com/rest/api/playfab/client/characters/getleaderboardforusercharacters
--]]
function PlayFabClientApi:GetLeaderboardForUserCharacters(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetLeaderboardForUserCharacters", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    For payments flows where the provider requires playfab (the fulfiller) to initiate the transaction, but the client
    completes the rest of the flow. In the Xsolla case, the token returned here will be passed to Xsolla by the client to
    create a cart. Poll GetPurchase using the returned OrderId once you've completed the payment.
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/getpaymenttoken
--]]
function PlayFabClientApi:GetPaymentToken(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPaymentToken", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Gets a Photon custom authentication token that can be used to securely join the player into a Photon room. See
    https://docs.microsoft.com/gaming/playfab/features/multiplayer/photon/quickstart for more details.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/getphotonauthenticationtoken
--]]
function PlayFabClientApi:GetPhotonAuthenticationToken(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPhotonAuthenticationToken", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves all of the user's different kinds of info.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayercombinedinfo
--]]
function PlayFabClientApi:GetPlayerCombinedInfo(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayerCombinedInfo", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the player's profile
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayerprofile
--]]
function PlayFabClientApi:GetPlayerProfile(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayerProfile", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    List all segments that a player currently belongs to at this moment in time.
    https://docs.microsoft.com/rest/api/playfab/client/playstream/getplayersegments
--]]
function PlayFabClientApi:GetPlayerSegments(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayerSegments", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the indicated statistics (current version and values for all statistics, if none are specified), for the local
    player.
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getplayerstatistics
--]]
function PlayFabClientApi:GetPlayerStatistics(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayerStatistics", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the information on the available versions of the specified statistic.
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getplayerstatisticversions
--]]
function PlayFabClientApi:GetPlayerStatisticVersions(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayerStatisticVersions", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Get all tags with a given Namespace (optional) from a player profile.
    https://docs.microsoft.com/rest/api/playfab/client/playstream/getplayertags
--]]
function PlayFabClientApi:GetPlayerTags(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayerTags", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Gets all trades the player has either opened or accepted, optionally filtered by trade status.
    https://docs.microsoft.com/rest/api/playfab/client/trading/getplayertrades
--]]
function PlayFabClientApi:GetPlayerTrades(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayerTrades", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Facebook identifiers.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromfacebookids
--]]
function PlayFabClientApi:GetPlayFabIDsFromFacebookIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromFacebookIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Facebook Instant Game identifiers.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromfacebookinstantgamesids
--]]
function PlayFabClientApi:GetPlayFabIDsFromFacebookInstantGamesIds(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromFacebookInstantGamesIds", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Game Center identifiers (referenced in the Game Center
    Programming Guide as the Player Identifier).
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromgamecenterids
--]]
function PlayFabClientApi:GetPlayFabIDsFromGameCenterIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromGameCenterIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of generic service identifiers. A generic identifier is the
    service name plus the service-specific ID for the player, as specified by the title when the generic identifier was
    added to the player account.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromgenericids
--]]
function PlayFabClientApi:GetPlayFabIDsFromGenericIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromGenericIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Google identifiers. The Google identifiers are the IDs for
    the user accounts, available as "id" in the Google+ People API calls.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromgoogleids
--]]
function PlayFabClientApi:GetPlayFabIDsFromGoogleIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromGoogleIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Kongregate identifiers. The Kongregate identifiers are the
    IDs for the user accounts, available as "user_id" from the Kongregate API methods(ex:
    http://developers.kongregate.com/docs/client/getUserId).
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromkongregateids
--]]
function PlayFabClientApi:GetPlayFabIDsFromKongregateIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromKongregateIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Nintendo Switch identifiers.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromnintendoswitchdeviceids
--]]
function PlayFabClientApi:GetPlayFabIDsFromNintendoSwitchDeviceIds(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromNintendoSwitchDeviceIds", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of PlayStation Network identifiers.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfrompsnaccountids
--]]
function PlayFabClientApi:GetPlayFabIDsFromPSNAccountIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromPSNAccountIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Steam identifiers. The Steam identifiers are the profile
    IDs for the user accounts, available as SteamId in the Steamworks Community API calls.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromsteamids
--]]
function PlayFabClientApi:GetPlayFabIDsFromSteamIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromSteamIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Twitch identifiers. The Twitch identifiers are the IDs for
    the user accounts, available as "_id" from the Twitch API methods (ex:
    https://github.com/justintv/Twitch-API/blob/master/v3_resources/users.md#get-usersuser).
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromtwitchids
--]]
function PlayFabClientApi:GetPlayFabIDsFromTwitchIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromTwitchIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of XboxLive identifiers.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/getplayfabidsfromxboxliveids
--]]
function PlayFabClientApi:GetPlayFabIDsFromXboxLiveIDs(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPlayFabIDsFromXboxLiveIDs", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the key-value store of custom publisher settings
    https://docs.microsoft.com/rest/api/playfab/client/title-wide-data-management/getpublisherdata
--]]
function PlayFabClientApi:GetPublisherData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPublisherData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves a purchase along with its current PlayFab status. Returns inventory items from the purchase that are still
    active.
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/getpurchase
--]]
function PlayFabClientApi:GetPurchase(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetPurchase", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves data stored in a shared group object, as well as the list of members in the group. Non-members of the group
    may use this to retrieve group data, including membership, but they will not receive data for keys marked as private.
    Shared Groups are designed for sharing data between a very small number of players, please see our guide:
    https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/client/shared-group-data/getsharedgroupdata
--]]
function PlayFabClientApi:GetSharedGroupData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetSharedGroupData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the set of items defined for the specified store, including all prices defined
    https://docs.microsoft.com/rest/api/playfab/client/title-wide-data-management/getstoreitems
--]]
function PlayFabClientApi:GetStoreItems(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetStoreItems", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the current server time
    https://docs.microsoft.com/rest/api/playfab/client/title-wide-data-management/gettime
--]]
function PlayFabClientApi:GetTime(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetTime", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the key-value store of custom title settings
    https://docs.microsoft.com/rest/api/playfab/client/title-wide-data-management/gettitledata
--]]
function PlayFabClientApi:GetTitleData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetTitleData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the title news feed, as configured in the developer portal
    https://docs.microsoft.com/rest/api/playfab/client/title-wide-data-management/gettitlenews
--]]
function PlayFabClientApi:GetTitleNews(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetTitleNews", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Returns the title's base 64 encoded RSA CSP blob.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/gettitlepublickey
--]]
function PlayFabClientApi:GetTitlePublicKey(request)
    return Promise.new(function(resolve, reject)
            IPlayFabHttps.MakePlayFabApiCall("/Client/GetTitlePublicKey", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Gets the current status of an existing trade.
    https://docs.microsoft.com/rest/api/playfab/client/trading/gettradestatus
--]]
function PlayFabClientApi:GetTradeStatus(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetTradeStatus", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getuserdata
--]]
function PlayFabClientApi:GetUserData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetUserData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the user's current inventory of virtual goods
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/getuserinventory
--]]
function PlayFabClientApi:GetUserInventory(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetUserInventory", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the publisher-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getuserpublisherdata
--]]
function PlayFabClientApi:GetUserPublisherData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetUserPublisherData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the publisher-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getuserpublisherreadonlydata
--]]
function PlayFabClientApi:GetUserPublisherReadOnlyData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetUserPublisherReadOnlyData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/getuserreadonlydata
--]]
function PlayFabClientApi:GetUserReadOnlyData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GetUserReadOnlyData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Requests a challenge from the server to be signed by Windows Hello Passport service to authenticate.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/getwindowshellochallenge
--]]
function PlayFabClientApi:GetWindowsHelloChallenge(request)
    return Promise.new(function(resolve, reject)
            IPlayFabHttps.MakePlayFabApiCall("/Client/GetWindowsHelloChallenge", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Grants the specified character type to the user. CharacterIds are not globally unique; characterId must be evaluated
    with the parent PlayFabId to guarantee uniqueness.
    https://docs.microsoft.com/rest/api/playfab/client/characters/grantcharactertouser
--]]
function PlayFabClientApi:GrantCharacterToUser(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/GrantCharacterToUser", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Android device identifier to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkandroiddeviceid
--]]
function PlayFabClientApi:LinkAndroidDeviceID(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkAndroidDeviceID", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Apple account associated with the token to the user's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkapple
--]]
function PlayFabClientApi:LinkApple(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkApple", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the custom identifier, generated by the title, to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkcustomid
--]]
function PlayFabClientApi:LinkCustomID(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkCustomID", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Facebook account associated with the provided Facebook access token to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkfacebookaccount
--]]
function PlayFabClientApi:LinkFacebookAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkFacebookAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Facebook Instant Games Id to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkfacebookinstantgamesid
--]]
function PlayFabClientApi:LinkFacebookInstantGamesId(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkFacebookInstantGamesId", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Game Center account associated with the provided Game Center ID to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkgamecenteraccount
--]]
function PlayFabClientApi:LinkGameCenterAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkGameCenterAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the currently signed-in user account to their Google account, using their Google account credentials
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkgoogleaccount
--]]
function PlayFabClientApi:LinkGoogleAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkGoogleAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the vendor-specific iOS device identifier to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkiosdeviceid
--]]
function PlayFabClientApi:LinkIOSDeviceID(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkIOSDeviceID", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Kongregate identifier to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkkongregate
--]]
function PlayFabClientApi:LinkKongregate(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkKongregate", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Nintendo account associated with the token to the user's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linknintendoserviceaccount
--]]
function PlayFabClientApi:LinkNintendoServiceAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkNintendoServiceAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the NintendoSwitchDeviceId to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linknintendoswitchdeviceid
--]]
function PlayFabClientApi:LinkNintendoSwitchDeviceId(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkNintendoSwitchDeviceId", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links an OpenID Connect account to a user's PlayFab account, based on an existing relationship between a title and an
    Open ID Connect provider and the OpenId Connect JWT from that provider.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkopenidconnect
--]]
function PlayFabClientApi:LinkOpenIdConnect(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkOpenIdConnect", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the PlayStation Network account associated with the provided access code to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkpsnaccount
--]]
function PlayFabClientApi:LinkPSNAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkPSNAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Steam account associated with the provided Steam authentication ticket to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linksteamaccount
--]]
function PlayFabClientApi:LinkSteamAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkSteamAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Twitch account associated with the token to the user's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linktwitch
--]]
function PlayFabClientApi:LinkTwitch(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkTwitch", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Link Windows Hello authentication to the current PlayFab Account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkwindowshello
--]]
function PlayFabClientApi:LinkWindowsHello(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkWindowsHello", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Links the Xbox Live account associated with the provided access code to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/linkxboxaccount
--]]
function PlayFabClientApi:LinkXboxAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/LinkXboxAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Signs the user in using the Android device identifier, returning a session identifier that can subsequently be used for
    API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithandroiddeviceid
--]]
function PlayFabClientApi:LoginWithAndroidDeviceID(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithAndroidDeviceID", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs in the user with a Sign in with Apple identity token.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithapple
--]]
function PlayFabClientApi:LoginWithApple(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithApple", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a custom unique identifier generated by the title, returning a session identifier that can
    subsequently be used for API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithcustomid
--]]
function PlayFabClientApi:LoginWithCustomID(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithCustomID", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user into the PlayFab account, returning a session identifier that can subsequently be used for API calls
    which require an authenticated user. Unlike most other login API calls, LoginWithEmailAddress does not permit the
    creation of new accounts via the CreateAccountFlag. Email addresses may be used to create accounts via
    RegisterPlayFabUser.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithemailaddress
--]]
function PlayFabClientApi:LoginWithEmailAddress(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithEmailAddress", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a Facebook access token, returning a session identifier that can subsequently be used for API
    calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithfacebook
--]]
function PlayFabClientApi:LoginWithFacebook(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithFacebook", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a Facebook Instant Games ID, returning a session identifier that can subsequently be used for
    API calls which require an authenticated user. Requires Facebook Instant Games to be configured.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithfacebookinstantgamesid
--]]
function PlayFabClientApi:LoginWithFacebookInstantGamesId(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithFacebookInstantGamesId", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using an iOS Game Center player identifier, returning a session identifier that can subsequently be
    used for API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithgamecenter
--]]
function PlayFabClientApi:LoginWithGameCenter(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithGameCenter", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using their Google account credentials
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithgoogleaccount
--]]
function PlayFabClientApi:LoginWithGoogleAccount(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithGoogleAccount", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using the vendor-specific iOS device identifier, returning a session identifier that can subsequently
    be used for API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithiosdeviceid
--]]
function PlayFabClientApi:LoginWithIOSDeviceID(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithIOSDeviceID", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a Kongregate player account.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithkongregate
--]]
function PlayFabClientApi:LoginWithKongregate(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithKongregate", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs in the user with a Nintendo service account token.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithnintendoserviceaccount
--]]
function PlayFabClientApi:LoginWithNintendoServiceAccount(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithNintendoServiceAccount", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a Nintendo Switch Device ID, returning a session identifier that can subsequently be used for
    API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithnintendoswitchdeviceid
--]]
function PlayFabClientApi:LoginWithNintendoSwitchDeviceId(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithNintendoSwitchDeviceId", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Logs in a user with an Open ID Connect JWT created by an existing relationship between a title and an Open ID Connect
    provider.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithopenidconnect
--]]
function PlayFabClientApi:LoginWithOpenIdConnect(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithOpenIdConnect", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user into the PlayFab account, returning a session identifier that can subsequently be used for API calls
    which require an authenticated user. Unlike most other login API calls, LoginWithPlayFab does not permit the creation of
    new accounts via the CreateAccountFlag. Username/Password credentials may be used to create accounts via
    RegisterPlayFabUser, or added to existing accounts using AddUsernamePassword.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithplayfab
--]]
function PlayFabClientApi:LoginWithPlayFab(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithPlayFab", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a PlayStation Network authentication code, returning a session identifier that can subsequently
    be used for API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithpsn
--]]
function PlayFabClientApi:LoginWithPSN(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithPSN", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a Steam authentication ticket, returning a session identifier that can subsequently be used for
    API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithsteam
--]]
function PlayFabClientApi:LoginWithSteam(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithSteam", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a Twitch access token.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithtwitch
--]]
function PlayFabClientApi:LoginWithTwitch(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithTwitch", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Completes the Windows Hello login flow by returning the signed value of the challange from GetWindowsHelloChallenge.
    Windows Hello has a 2 step client to server authentication scheme. Step one is to request from the server a challenge
    string. Step two is to request the user sign the string via Windows Hello and then send the signed value back to the
    server.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithwindowshello
--]]
function PlayFabClientApi:LoginWithWindowsHello(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithWindowsHello", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Signs the user in using a Xbox Live Token, returning a session identifier that can subsequently be used for API calls
    which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/loginwithxbox
--]]
function PlayFabClientApi:LoginWithXbox(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/LoginWithXbox", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Attempts to locate a game session matching the given parameters. If the goal is to match the player into a specific
    active session, only the LobbyId is required. Otherwise, the BuildVersion, GameMode, and Region are all required
    parameters. Note that parameters specified in the search are required (they are not weighting factors). If a slot is
    found in a server instance matching the parameters, the slot will be assigned to that player, removing it from the
    availabe set. In that case, the information on the game session will be returned, otherwise the Status returned will be
    GameNotFound.
    https://docs.microsoft.com/rest/api/playfab/client/matchmaking/matchmake
--]]
function PlayFabClientApi:Matchmake(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/Matchmake", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Opens a new outstanding trade. Note that a given item instance may only be in one open trade at a time.
    https://docs.microsoft.com/rest/api/playfab/client/trading/opentrade
--]]
function PlayFabClientApi:OpenTrade(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/OpenTrade", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Selects a payment option for purchase order created via StartPurchase
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/payforpurchase
--]]
function PlayFabClientApi:PayForPurchase(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/PayForPurchase", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Buys a single item with virtual currency. You must specify both the virtual currency to use to purchase, as well as what
    the client believes the price to be. This lets the server fail the purchase if the price has changed.
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/purchaseitem
--]]
function PlayFabClientApi:PurchaseItem(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/PurchaseItem", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Adds the virtual goods associated with the coupon to the user's inventory. Coupons can be generated via the
    Economy->Catalogs tab in the PlayFab Game Manager.
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/redeemcoupon
--]]
function PlayFabClientApi:RedeemCoupon(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RedeemCoupon", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Uses the supplied OAuth code to refresh the internally cached player PSN auth token
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/refreshpsnauthtoken
--]]
function PlayFabClientApi:RefreshPSNAuthToken(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RefreshPSNAuthToken", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Registers the iOS device to receive push notifications
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/registerforiospushnotification
--]]
function PlayFabClientApi:RegisterForIOSPushNotification(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RegisterForIOSPushNotification", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Registers a new Playfab user account, returning a session identifier that can subsequently be used for API calls which
    require an authenticated user. You must supply either a username or an email address.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/registerplayfabuser
--]]
function PlayFabClientApi:RegisterPlayFabUser(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/RegisterPlayFabUser", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Registers a new PlayFab user account using Windows Hello authentication, returning a session ticket that can
    subsequently be used for API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/client/authentication/registerwithwindowshello
--]]
function PlayFabClientApi:RegisterWithWindowsHello(request)
    return Promise.new(function(resolve, reject)
         request.TitleId = PlayFabSettings.settings.titleId
        IPlayFabHttps.MakePlayFabApiCall("/Client/RegisterWithWindowsHello", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Removes a contact email from the player's profile.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/removecontactemail
--]]
function PlayFabClientApi:RemoveContactEmail(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RemoveContactEmail", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Removes a specified user from the friend list of the local user
    https://docs.microsoft.com/rest/api/playfab/client/friend-list-management/removefriend
--]]
function PlayFabClientApi:RemoveFriend(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RemoveFriend", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Removes the specified generic service identifier from the player's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/removegenericid
--]]
function PlayFabClientApi:RemoveGenericID(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RemoveGenericID", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Removes users from the set of those able to update the shared data and the set of users in the group. Only users in the
    group can remove members. If as a result of the call, zero users remain with access, the group and its associated data
    will be deleted. Shared Groups are designed for sharing data between a very small number of players, please see our
    guide: https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/client/shared-group-data/removesharedgroupmembers
--]]
function PlayFabClientApi:RemoveSharedGroupMembers(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RemoveSharedGroupMembers", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Report player's ad activity
    https://docs.microsoft.com/rest/api/playfab/client/advertising/reportadactivity
--]]
function PlayFabClientApi:ReportAdActivity(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ReportAdActivity", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Write a PlayStream event to describe the provided player device information. This API method is not designed to be
    called directly by developers. Each PlayFab client SDK will eventually report this information automatically.
    https://docs.microsoft.com/rest/api/playfab/client/analytics/reportdeviceinfo
--]]
function PlayFabClientApi:ReportDeviceInfo(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ReportDeviceInfo", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Submit a report for another player (due to bad bahavior, etc.), so that customer service representatives for the title
    can take action concerning potentially toxic players.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/reportplayer
--]]
function PlayFabClientApi:ReportPlayer(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ReportPlayer", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Restores all in-app purchases based on the given restore receipt
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/restoreiospurchases
--]]
function PlayFabClientApi:RestoreIOSPurchases(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RestoreIOSPurchases", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Reward player's ad activity
    https://docs.microsoft.com/rest/api/playfab/client/advertising/rewardadactivity
--]]
function PlayFabClientApi:RewardAdActivity(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/RewardAdActivity", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Forces an email to be sent to the registered email address for the user's account, with a link allowing the user to
    change the password.If an account recovery email template ID is provided, an email using the custom email template will
    be used.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/sendaccountrecoveryemail
--]]
function PlayFabClientApi:SendAccountRecoveryEmail(request)
    return Promise.new(function(resolve, reject)
            IPlayFabHttps.MakePlayFabApiCall("/Client/SendAccountRecoveryEmail", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Updates the tag list for a specified user in the friend list of the local user
    https://docs.microsoft.com/rest/api/playfab/client/friend-list-management/setfriendtags
--]]
function PlayFabClientApi:SetFriendTags(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/SetFriendTags", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Sets the player's secret if it is not already set. Player secrets are used to sign API requests. To reset a player's
    secret use the Admin or Server API method SetPlayerSecret.
    https://docs.microsoft.com/rest/api/playfab/client/authentication/setplayersecret
--]]
function PlayFabClientApi:SetPlayerSecret(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/SetPlayerSecret", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Start a new game server with a given configuration, add the current player and return the connection information.
    https://docs.microsoft.com/rest/api/playfab/client/matchmaking/startgame
--]]
function PlayFabClientApi:StartGame(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/StartGame", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Creates an order for a list of items from the title catalog
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/startpurchase
--]]
function PlayFabClientApi:StartPurchase(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/StartPurchase", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Decrements the user's balance of the specified virtual currency by the stated amount. It is possible to make a VC
    balance negative with this API.
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/subtractuservirtualcurrency
--]]
function PlayFabClientApi:SubtractUserVirtualCurrency(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/SubtractUserVirtualCurrency", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Android device identifier from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkandroiddeviceid
--]]
function PlayFabClientApi:UnlinkAndroidDeviceID(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkAndroidDeviceID", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Apple account from the user's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkapple
--]]
function PlayFabClientApi:UnlinkApple(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkApple", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related custom identifier from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkcustomid
--]]
function PlayFabClientApi:UnlinkCustomID(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkCustomID", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Facebook account from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkfacebookaccount
--]]
function PlayFabClientApi:UnlinkFacebookAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkFacebookAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Facebook Instant Game Ids from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkfacebookinstantgamesid
--]]
function PlayFabClientApi:UnlinkFacebookInstantGamesId(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkFacebookInstantGamesId", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Game Center account from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkgamecenteraccount
--]]
function PlayFabClientApi:UnlinkGameCenterAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkGameCenterAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Google account from the user's PlayFab account
    (https://developers.google.com/android/reference/com/google/android/gms/auth/GoogleAuthUtil#public-methods).
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkgoogleaccount
--]]
function PlayFabClientApi:UnlinkGoogleAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkGoogleAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related iOS device identifier from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkiosdeviceid
--]]
function PlayFabClientApi:UnlinkIOSDeviceID(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkIOSDeviceID", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Kongregate identifier from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkkongregate
--]]
function PlayFabClientApi:UnlinkKongregate(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkKongregate", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Nintendo account from the user's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinknintendoserviceaccount
--]]
function PlayFabClientApi:UnlinkNintendoServiceAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkNintendoServiceAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related NintendoSwitchDeviceId from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinknintendoswitchdeviceid
--]]
function PlayFabClientApi:UnlinkNintendoSwitchDeviceId(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkNintendoSwitchDeviceId", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks an OpenID Connect account from a user's PlayFab account, based on the connection ID of an existing relationship
    between a title and an Open ID Connect provider.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkopenidconnect
--]]
function PlayFabClientApi:UnlinkOpenIdConnect(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkOpenIdConnect", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related PSN account from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkpsnaccount
--]]
function PlayFabClientApi:UnlinkPSNAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkPSNAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Steam account from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinksteamaccount
--]]
function PlayFabClientApi:UnlinkSteamAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkSteamAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Twitch account from the user's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinktwitch
--]]
function PlayFabClientApi:UnlinkTwitch(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkTwitch", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlink Windows Hello authentication from the current PlayFab Account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkwindowshello
--]]
function PlayFabClientApi:UnlinkWindowsHello(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkWindowsHello", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Unlinks the related Xbox Live account from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/client/account-management/unlinkxboxaccount
--]]
function PlayFabClientApi:UnlinkXboxAccount(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlinkXboxAccount", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Opens the specified container, with the specified key (when required), and returns the contents of the opened container.
    If the container (and key when relevant) are consumable (RemainingUses > 0), their RemainingUses will be decremented,
    consistent with the operation of ConsumeItem.
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/unlockcontainerinstance
--]]
function PlayFabClientApi:UnlockContainerInstance(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlockContainerInstance", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Searches target inventory for an ItemInstance matching the given CatalogItemId, if necessary unlocks it using an
    appropriate key, and returns the contents of the opened container. If the container (and key when relevant) are
    consumable (RemainingUses > 0), their RemainingUses will be decremented, consistent with the operation of ConsumeItem.
    https://docs.microsoft.com/rest/api/playfab/client/player-item-management/unlockcontaineritem
--]]
function PlayFabClientApi:UnlockContainerItem(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UnlockContainerItem", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Update the avatar URL of the player
    https://docs.microsoft.com/rest/api/playfab/client/account-management/updateavatarurl
--]]
function PlayFabClientApi:UpdateAvatarUrl(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UpdateAvatarUrl", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Creates and updates the title-specific custom data for the user's character which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/client/character-data/updatecharacterdata
--]]
function PlayFabClientApi:UpdateCharacterData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UpdateCharacterData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Updates the values of the specified title-specific statistics for the specific character. By default, clients are not
    permitted to update statistics. Developers may override this setting in the Game Manager > Settings > API Features.
    https://docs.microsoft.com/rest/api/playfab/client/characters/updatecharacterstatistics
--]]
function PlayFabClientApi:UpdateCharacterStatistics(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UpdateCharacterStatistics", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Updates the values of the specified title-specific statistics for the user. By default, clients are not permitted to
    update statistics. Developers may override this setting in the Game Manager > Settings > API Features.
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/updateplayerstatistics
--]]
function PlayFabClientApi:UpdatePlayerStatistics(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UpdatePlayerStatistics", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Adds, updates, and removes data keys for a shared group object. If the permission is set to Public, all fields updated
    or added in this call will be readable by users not in the group. By default, data permissions are set to Private.
    Regardless of the permission setting, only members of the group can update the data. Shared Groups are designed for
    sharing data between a very small number of players, please see our guide:
    https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/client/shared-group-data/updatesharedgroupdata
--]]
function PlayFabClientApi:UpdateSharedGroupData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UpdateSharedGroupData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Creates and updates the title-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/updateuserdata
--]]
function PlayFabClientApi:UpdateUserData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UpdateUserData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Creates and updates the publisher-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/client/player-data-management/updateuserpublisherdata
--]]
function PlayFabClientApi:UpdateUserPublisherData(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UpdateUserPublisherData", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Updates the title specific display name for the user
    https://docs.microsoft.com/rest/api/playfab/client/account-management/updateusertitledisplayname
--]]
function PlayFabClientApi:UpdateUserTitleDisplayName(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/UpdateUserTitleDisplayName", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Validates with Amazon that the receipt for an Amazon App Store in-app purchase is valid and that it matches the
    purchased catalog item
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/validateamazoniapreceipt
--]]
function PlayFabClientApi:ValidateAmazonIAPReceipt(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ValidateAmazonIAPReceipt", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Validates a Google Play purchase and gives the corresponding item to the player.
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/validategoogleplaypurchase
--]]
function PlayFabClientApi:ValidateGooglePlayPurchase(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ValidateGooglePlayPurchase", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Validates with the Apple store that the receipt for an iOS in-app purchase is valid and that it matches the purchased
    catalog item
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/validateiosreceipt
--]]
function PlayFabClientApi:ValidateIOSReceipt(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ValidateIOSReceipt", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Validates with Windows that the receipt for an Windows App Store in-app purchase is valid and that it matches the
    purchased catalog item
    https://docs.microsoft.com/rest/api/playfab/client/platform-specific-methods/validatewindowsstorereceipt
--]]
function PlayFabClientApi:ValidateWindowsStoreReceipt(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/ValidateWindowsStoreReceipt", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Writes a character-based event into PlayStream.
    https://docs.microsoft.com/rest/api/playfab/client/analytics/writecharacterevent
--]]
function PlayFabClientApi:WriteCharacterEvent(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/WriteCharacterEvent", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Writes a player-based event into PlayStream.
    https://docs.microsoft.com/rest/api/playfab/client/analytics/writeplayerevent
--]]
function PlayFabClientApi:WritePlayerEvent(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/WritePlayerEvent", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

--[[
    Writes a title-based event into PlayStream.
    https://docs.microsoft.com/rest/api/playfab/client/analytics/writetitleevent
--]]
function PlayFabClientApi:WriteTitleEvent(sessionTicket, request)
    return Promise.new(function(resolve, reject)
         if (not sessionTicket) then reject("Must provide a sessionTicket to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Client/WriteTitleEvent", request or {}, "X-Authorization", sessionTicket, resolve, reject)
    end)
end

return PlayFabClientApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">PlayFabCloudScript</string>
          <string name="Source"><![CDATA[-- PlayFab CloudScript API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabCloudScriptApi = {
    settings = PlayFabSettings.settings
}

--[[
    Cloud Script is one of PlayFab's most versatile features. It allows client code to request execution of any kind of
    custom server-side functionality you can implement, and it can be used in conjunction with virtually anything.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/executeentitycloudscript
--]]
function PlayFabCloudScriptApi:ExecuteEntityCloudScript(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/ExecuteEntityCloudScript", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Cloud Script is one of PlayFab's most versatile features. It allows client code to request execution of any kind of
    custom server-side functionality you can implement, and it can be used in conjunction with virtually anything.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/executefunction
--]]
function PlayFabCloudScriptApi:ExecuteFunction(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/ExecuteFunction", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all currently registered Azure Functions for a given title.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/listfunctions
--]]
function PlayFabCloudScriptApi:ListFunctions(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/ListFunctions", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all currently registered HTTP triggered Azure Functions for a given title.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/listhttpfunctions
--]]
function PlayFabCloudScriptApi:ListHttpFunctions(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/ListHttpFunctions", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all currently registered Queue triggered Azure Functions for a given title.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/listqueuedfunctions
--]]
function PlayFabCloudScriptApi:ListQueuedFunctions(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/ListQueuedFunctions", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Generate an entity PlayStream event for the provided function result.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/postfunctionresultforentitytriggeredaction
--]]
function PlayFabCloudScriptApi:PostFunctionResultForEntityTriggeredAction(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/PostFunctionResultForEntityTriggeredAction", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Generate an entity PlayStream event for the provided function result.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/postfunctionresultforfunctionexecution
--]]
function PlayFabCloudScriptApi:PostFunctionResultForFunctionExecution(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/PostFunctionResultForFunctionExecution", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Generate a player PlayStream event for the provided function result.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/postfunctionresultforplayertriggeredaction
--]]
function PlayFabCloudScriptApi:PostFunctionResultForPlayerTriggeredAction(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/PostFunctionResultForPlayerTriggeredAction", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Generate a PlayStream event for the provided function result.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/postfunctionresultforscheduledtask
--]]
function PlayFabCloudScriptApi:PostFunctionResultForScheduledTask(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/PostFunctionResultForScheduledTask", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Registers an HTTP triggered Azure function with a title.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/registerhttpfunction
--]]
function PlayFabCloudScriptApi:RegisterHttpFunction(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/RegisterHttpFunction", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Registers a queue triggered Azure Function with a title.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/registerqueuedfunction
--]]
function PlayFabCloudScriptApi:RegisterQueuedFunction(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/RegisterQueuedFunction", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Unregisters an Azure Function with a title.
    https://docs.microsoft.com/rest/api/playfab/cloudscript/server-side-cloud-script/unregisterfunction
--]]
function PlayFabCloudScriptApi:UnregisterFunction(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/CloudScript/UnregisterFunction", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabCloudScriptApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">PlayFabData</string>
          <string name="Source"><![CDATA[-- PlayFab Data API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabDataApi = {
    settings = PlayFabSettings.settings
}

--[[
    Abort pending file uploads to an entity's profile.
    https://docs.microsoft.com/rest/api/playfab/data/file/abortfileuploads
--]]
function PlayFabDataApi:AbortFileUploads(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/File/AbortFileUploads", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Delete files on an entity's profile.
    https://docs.microsoft.com/rest/api/playfab/data/file/deletefiles
--]]
function PlayFabDataApi:DeleteFiles(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/File/DeleteFiles", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Finalize file uploads to an entity's profile.
    https://docs.microsoft.com/rest/api/playfab/data/file/finalizefileuploads
--]]
function PlayFabDataApi:FinalizeFileUploads(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/File/FinalizeFileUploads", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Retrieves file metadata from an entity's profile.
    https://docs.microsoft.com/rest/api/playfab/data/file/getfiles
--]]
function PlayFabDataApi:GetFiles(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/File/GetFiles", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Retrieves objects from an entity's profile.
    https://docs.microsoft.com/rest/api/playfab/data/object/getobjects
--]]
function PlayFabDataApi:GetObjects(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Object/GetObjects", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Initiates file uploads to an entity's profile.
    https://docs.microsoft.com/rest/api/playfab/data/file/initiatefileuploads
--]]
function PlayFabDataApi:InitiateFileUploads(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/File/InitiateFileUploads", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Sets objects on an entity's profile.
    https://docs.microsoft.com/rest/api/playfab/data/object/setobjects
--]]
function PlayFabDataApi:SetObjects(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Object/SetObjects", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabDataApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="8">
        <Properties>
          <string name="Name">PlayFabEvents</string>
          <string name="Source"><![CDATA[-- PlayFab Events API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabEventsApi = {
    settings = PlayFabSettings.settings
}

--[[
    Write batches of entity based events to PlayStream. The namespace of the Event must be 'custom' or start with 'custom.'.
    https://docs.microsoft.com/rest/api/playfab/events/playstream-events/writeevents
--]]
function PlayFabEventsApi:WriteEvents(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Event/WriteEvents", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Write batches of entity based events to as Telemetry events (bypass PlayStream). The namespace must be 'custom' or start
    with 'custom.'
    https://docs.microsoft.com/rest/api/playfab/events/playstream-events/writetelemetryevents
--]]
function PlayFabEventsApi:WriteTelemetryEvents(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Event/WriteTelemetryEvents", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabEventsApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="9">
        <Properties>
          <string name="Name">PlayFabExperimentation</string>
          <string name="Source"><![CDATA[-- PlayFab Experimentation API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabExperimentationApi = {
    settings = PlayFabSettings.settings
}

--[[
    Creates a new experiment for a title.
    https://docs.microsoft.com/rest/api/playfab/experimentation/experimentation/createexperiment
--]]
function PlayFabExperimentationApi:CreateExperiment(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Experimentation/CreateExperiment", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes an existing experiment for a title.
    https://docs.microsoft.com/rest/api/playfab/experimentation/experimentation/deleteexperiment
--]]
function PlayFabExperimentationApi:DeleteExperiment(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Experimentation/DeleteExperiment", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets the details of all experiments for a title.
    https://docs.microsoft.com/rest/api/playfab/experimentation/experimentation/getexperiments
--]]
function PlayFabExperimentationApi:GetExperiments(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Experimentation/GetExperiments", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets the latest scorecard of the experiment for the title.
    https://docs.microsoft.com/rest/api/playfab/experimentation/experimentation/getlatestscorecard
--]]
function PlayFabExperimentationApi:GetLatestScorecard(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Experimentation/GetLatestScorecard", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets the treatment assignments for a player for every running experiment in the title.
    https://docs.microsoft.com/rest/api/playfab/experimentation/experimentation/gettreatmentassignment
--]]
function PlayFabExperimentationApi:GetTreatmentAssignment(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Experimentation/GetTreatmentAssignment", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Starts an existing experiment for a title.
    https://docs.microsoft.com/rest/api/playfab/experimentation/experimentation/startexperiment
--]]
function PlayFabExperimentationApi:StartExperiment(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Experimentation/StartExperiment", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Stops an existing experiment for a title.
    https://docs.microsoft.com/rest/api/playfab/experimentation/experimentation/stopexperiment
--]]
function PlayFabExperimentationApi:StopExperiment(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Experimentation/StopExperiment", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Updates an existing experiment for a title.
    https://docs.microsoft.com/rest/api/playfab/experimentation/experimentation/updateexperiment
--]]
function PlayFabExperimentationApi:UpdateExperiment(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Experimentation/UpdateExperiment", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabExperimentationApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="10">
        <Properties>
          <string name="Name">PlayFabGroups</string>
          <string name="Source"><![CDATA[-- PlayFab Groups API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabGroupsApi = {
    settings = PlayFabSettings.settings
}

--[[
    Accepts an outstanding invitation to to join a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/acceptgroupapplication
--]]
function PlayFabGroupsApi:AcceptGroupApplication(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/AcceptGroupApplication", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Accepts an invitation to join a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/acceptgroupinvitation
--]]
function PlayFabGroupsApi:AcceptGroupInvitation(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/AcceptGroupInvitation", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Adds members to a group or role.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/addmembers
--]]
function PlayFabGroupsApi:AddMembers(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/AddMembers", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Applies to join a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/applytogroup
--]]
function PlayFabGroupsApi:ApplyToGroup(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/ApplyToGroup", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Blocks a list of entities from joining a group.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/blockentity
--]]
function PlayFabGroupsApi:BlockEntity(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/BlockEntity", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Changes the role membership of a list of entities from one role to another.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/changememberrole
--]]
function PlayFabGroupsApi:ChangeMemberRole(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/ChangeMemberRole", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Creates a new group.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/creategroup
--]]
function PlayFabGroupsApi:CreateGroup(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/CreateGroup", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Creates a new group role.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/createrole
--]]
function PlayFabGroupsApi:CreateRole(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/CreateRole", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes a group and all roles, invitations, join requests, and blocks associated with it.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/deletegroup
--]]
function PlayFabGroupsApi:DeleteGroup(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/DeleteGroup", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes an existing role in a group.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/deleterole
--]]
function PlayFabGroupsApi:DeleteRole(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/DeleteRole", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets information about a group and its roles
    https://docs.microsoft.com/rest/api/playfab/groups/groups/getgroup
--]]
function PlayFabGroupsApi:GetGroup(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/GetGroup", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Invites a player to join a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/invitetogroup
--]]
function PlayFabGroupsApi:InviteToGroup(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/InviteToGroup", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Checks to see if an entity is a member of a group or role within the group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/ismember
--]]
function PlayFabGroupsApi:IsMember(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/IsMember", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all outstanding requests to join a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/listgroupapplications
--]]
function PlayFabGroupsApi:ListGroupApplications(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/ListGroupApplications", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all entities blocked from joining a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/listgroupblocks
--]]
function PlayFabGroupsApi:ListGroupBlocks(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/ListGroupBlocks", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all outstanding invitations for a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/listgroupinvitations
--]]
function PlayFabGroupsApi:ListGroupInvitations(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/ListGroupInvitations", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all members for a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/listgroupmembers
--]]
function PlayFabGroupsApi:ListGroupMembers(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/ListGroupMembers", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all groups and roles for an entity
    https://docs.microsoft.com/rest/api/playfab/groups/groups/listmembership
--]]
function PlayFabGroupsApi:ListMembership(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/ListMembership", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists all outstanding invitations and group applications for an entity
    https://docs.microsoft.com/rest/api/playfab/groups/groups/listmembershipopportunities
--]]
function PlayFabGroupsApi:ListMembershipOpportunities(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/ListMembershipOpportunities", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Removes an application to join a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/removegroupapplication
--]]
function PlayFabGroupsApi:RemoveGroupApplication(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/RemoveGroupApplication", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Removes an invitation join a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/removegroupinvitation
--]]
function PlayFabGroupsApi:RemoveGroupInvitation(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/RemoveGroupInvitation", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Removes members from a group.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/removemembers
--]]
function PlayFabGroupsApi:RemoveMembers(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/RemoveMembers", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Unblocks a list of entities from joining a group
    https://docs.microsoft.com/rest/api/playfab/groups/groups/unblockentity
--]]
function PlayFabGroupsApi:UnblockEntity(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/UnblockEntity", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Updates non-membership data about a group.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/updategroup
--]]
function PlayFabGroupsApi:UpdateGroup(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/UpdateGroup", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Updates metadata about a role.
    https://docs.microsoft.com/rest/api/playfab/groups/groups/updaterole
--]]
function PlayFabGroupsApi:UpdateRole(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Group/UpdateRole", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabGroupsApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="11">
        <Properties>
          <string name="Name">PlayFabInsights</string>
          <string name="Source"><![CDATA[-- PlayFab Insights API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabInsightsApi = {
    settings = PlayFabSettings.settings
}

--[[
    Gets the current values for the Insights performance and data storage retention, list of pending operations, and the
    performance and data storage retention limits.
    https://docs.microsoft.com/rest/api/playfab/insights/analytics/getdetails
--]]
function PlayFabInsightsApi:GetDetails(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Insights/GetDetails", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Retrieves the range of allowed values for performance and data storage retention values as well as the submeter details
    for each performance level.
    https://docs.microsoft.com/rest/api/playfab/insights/analytics/getlimits
--]]
function PlayFabInsightsApi:GetLimits(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Insights/GetLimits", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets the status of a SetPerformance or SetStorageRetention operation.
    https://docs.microsoft.com/rest/api/playfab/insights/analytics/getoperationstatus
--]]
function PlayFabInsightsApi:GetOperationStatus(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Insights/GetOperationStatus", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets a list of pending SetPerformance and/or SetStorageRetention operations for the title.
    https://docs.microsoft.com/rest/api/playfab/insights/analytics/getpendingoperations
--]]
function PlayFabInsightsApi:GetPendingOperations(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Insights/GetPendingOperations", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Sets the Insights performance level value for the title.
    https://docs.microsoft.com/rest/api/playfab/insights/analytics/setperformance
--]]
function PlayFabInsightsApi:SetPerformance(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Insights/SetPerformance", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Sets the Insights data storage retention days value for the title.
    https://docs.microsoft.com/rest/api/playfab/insights/analytics/setstorageretention
--]]
function PlayFabInsightsApi:SetStorageRetention(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Insights/SetStorageRetention", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabInsightsApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="12">
        <Properties>
          <string name="Name">PlayFabLocalization</string>
          <string name="Source"><![CDATA[-- PlayFab Localization API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabLocalizationApi = {
    settings = PlayFabSettings.settings
}

--[[
    Retrieves the list of allowed languages, only accessible by title entities
    https://docs.microsoft.com/rest/api/playfab/localization/localization/getlanguagelist
--]]
function PlayFabLocalizationApi:GetLanguageList(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Locale/GetLanguageList", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabLocalizationApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="13">
        <Properties>
          <string name="Name">PlayFabMatchmaker</string>
          <string name="Source"><![CDATA[-- PlayFab Matchmaker API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabMatchmakerApi = {
    settings = PlayFabSettings.settings
}

--[[
    Validates a user with the PlayFab service
    https://docs.microsoft.com/rest/api/playfab/matchmaker/matchmaking/authuser
--]]
function PlayFabMatchmakerApi:AuthUser(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Matchmaker/AuthUser", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Informs the PlayFab game server hosting service that the indicated user has joined the Game Server Instance specified
    https://docs.microsoft.com/rest/api/playfab/matchmaker/matchmaking/playerjoined
--]]
function PlayFabMatchmakerApi:PlayerJoined(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Matchmaker/PlayerJoined", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Informs the PlayFab game server hosting service that the indicated user has left the Game Server Instance specified
    https://docs.microsoft.com/rest/api/playfab/matchmaker/matchmaking/playerleft
--]]
function PlayFabMatchmakerApi:PlayerLeft(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Matchmaker/PlayerLeft", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Instructs the PlayFab game server hosting service to instantiate a new Game Server Instance
    https://docs.microsoft.com/rest/api/playfab/matchmaker/matchmaking/startgame
--]]
function PlayFabMatchmakerApi:StartGame(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Matchmaker/StartGame", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the relevant details for a specified user, which the external match-making service can then use to compute
    effective matches
    https://docs.microsoft.com/rest/api/playfab/matchmaker/matchmaking/userinfo
--]]
function PlayFabMatchmakerApi:UserInfo(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Matchmaker/UserInfo", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

return PlayFabMatchmakerApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="14">
        <Properties>
          <string name="Name">PlayFabMultiplayer</string>
          <string name="Source"><![CDATA[-- PlayFab Multiplayer API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabMultiplayerApi = {
    settings = PlayFabSettings.settings
}

--[[
    Cancel all active tickets the player is a member of in a given queue.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/cancelallmatchmakingticketsforplayer
--]]
function PlayFabMultiplayerApi:CancelAllMatchmakingTicketsForPlayer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/CancelAllMatchmakingTicketsForPlayer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Cancel all active backfill tickets the player is a member of in a given queue.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/cancelallserverbackfillticketsforplayer
--]]
function PlayFabMultiplayerApi:CancelAllServerBackfillTicketsForPlayer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/CancelAllServerBackfillTicketsForPlayer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Cancel a matchmaking ticket.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/cancelmatchmakingticket
--]]
function PlayFabMultiplayerApi:CancelMatchmakingTicket(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/CancelMatchmakingTicket", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Cancel a server backfill ticket.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/cancelserverbackfillticket
--]]
function PlayFabMultiplayerApi:CancelServerBackfillTicket(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/CancelServerBackfillTicket", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Creates a multiplayer server build alias.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/createbuildalias
--]]
function PlayFabMultiplayerApi:CreateBuildAlias(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/CreateBuildAlias", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Creates a multiplayer server build with a custom container.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/createbuildwithcustomcontainer
--]]
function PlayFabMultiplayerApi:CreateBuildWithCustomContainer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/CreateBuildWithCustomContainer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Creates a multiplayer server build with a managed container.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/createbuildwithmanagedcontainer
--]]
function PlayFabMultiplayerApi:CreateBuildWithManagedContainer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/CreateBuildWithManagedContainer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Creates a multiplayer server build with the server running as a process.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/createbuildwithprocessbasedserver
--]]
function PlayFabMultiplayerApi:CreateBuildWithProcessBasedServer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/CreateBuildWithProcessBasedServer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Create a matchmaking ticket as a client.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/creatematchmakingticket
--]]
function PlayFabMultiplayerApi:CreateMatchmakingTicket(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/CreateMatchmakingTicket", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Creates a remote user to log on to a VM for a multiplayer server build.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/createremoteuser
--]]
function PlayFabMultiplayerApi:CreateRemoteUser(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/CreateRemoteUser", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Create a backfill matchmaking ticket as a server. A backfill ticket represents an ongoing game. The matchmaking service
    automatically starts matching the backfill ticket against other matchmaking tickets. Backfill tickets cannot match with
    other backfill tickets.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/createserverbackfillticket
--]]
function PlayFabMultiplayerApi:CreateServerBackfillTicket(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/CreateServerBackfillTicket", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Create a matchmaking ticket as a server. The matchmaking service automatically starts matching the ticket against other
    matchmaking tickets.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/createservermatchmakingticket
--]]
function PlayFabMultiplayerApi:CreateServerMatchmakingTicket(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/CreateServerMatchmakingTicket", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes a multiplayer server game asset for a title.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/deleteasset
--]]
function PlayFabMultiplayerApi:DeleteAsset(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/DeleteAsset", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes a multiplayer server build.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/deletebuild
--]]
function PlayFabMultiplayerApi:DeleteBuild(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/DeleteBuild", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes a multiplayer server build alias.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/deletebuildalias
--]]
function PlayFabMultiplayerApi:DeleteBuildAlias(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/DeleteBuildAlias", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Removes a multiplayer server build's region.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/deletebuildregion
--]]
function PlayFabMultiplayerApi:DeleteBuildRegion(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/DeleteBuildRegion", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes a multiplayer server game certificate.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/deletecertificate
--]]
function PlayFabMultiplayerApi:DeleteCertificate(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/DeleteCertificate", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes a container image repository.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/deletecontainerimagerepository
--]]
function PlayFabMultiplayerApi:DeleteContainerImageRepository(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/DeleteContainerImageRepository", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Deletes a remote user to log on to a VM for a multiplayer server build.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/deleteremoteuser
--]]
function PlayFabMultiplayerApi:DeleteRemoteUser(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/DeleteRemoteUser", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Enables the multiplayer server feature for a title.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/enablemultiplayerserversfortitle
--]]
function PlayFabMultiplayerApi:EnableMultiplayerServersForTitle(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/EnableMultiplayerServersForTitle", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets the URL to upload assets to.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/getassetuploadurl
--]]
function PlayFabMultiplayerApi:GetAssetUploadUrl(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetAssetUploadUrl", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets a multiplayer server build.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/getbuild
--]]
function PlayFabMultiplayerApi:GetBuild(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetBuild", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets a multiplayer server build alias.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/getbuildalias
--]]
function PlayFabMultiplayerApi:GetBuildAlias(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetBuildAlias", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets the credentials to the container registry.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/getcontainerregistrycredentials
--]]
function PlayFabMultiplayerApi:GetContainerRegistryCredentials(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetContainerRegistryCredentials", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Get a match.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/getmatch
--]]
function PlayFabMultiplayerApi:GetMatch(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/GetMatch", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    SDK support is limited to C# and Java for this API. Get a matchmaking queue configuration.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking-admin/getmatchmakingqueue
--]]
function PlayFabMultiplayerApi:GetMatchmakingQueue(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/GetMatchmakingQueue", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Get a matchmaking ticket by ticket Id.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/getmatchmakingticket
--]]
function PlayFabMultiplayerApi:GetMatchmakingTicket(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/GetMatchmakingTicket", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets multiplayer server session details for a build.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/getmultiplayerserverdetails
--]]
function PlayFabMultiplayerApi:GetMultiplayerServerDetails(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetMultiplayerServerDetails", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets multiplayer server logs after a server has terminated.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/getmultiplayerserverlogs
--]]
function PlayFabMultiplayerApi:GetMultiplayerServerLogs(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetMultiplayerServerLogs", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets multiplayer server logs after a server has terminated.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/getmultiplayersessionlogsbysessionid
--]]
function PlayFabMultiplayerApi:GetMultiplayerSessionLogsBySessionId(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetMultiplayerSessionLogsBySessionId", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Get the statistics for a queue.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/getqueuestatistics
--]]
function PlayFabMultiplayerApi:GetQueueStatistics(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/GetQueueStatistics", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets a remote login endpoint to a VM that is hosting a multiplayer server build.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/getremoteloginendpoint
--]]
function PlayFabMultiplayerApi:GetRemoteLoginEndpoint(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetRemoteLoginEndpoint", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Get a matchmaking backfill ticket by ticket Id.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/getserverbackfillticket
--]]
function PlayFabMultiplayerApi:GetServerBackfillTicket(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/GetServerBackfillTicket", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets the status of whether a title is enabled for the multiplayer server feature.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/gettitleenabledformultiplayerserversstatus
--]]
function PlayFabMultiplayerApi:GetTitleEnabledForMultiplayerServersStatus(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetTitleEnabledForMultiplayerServersStatus", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Gets the quotas for a title in relation to multiplayer servers.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/gettitlemultiplayerserversquotas
--]]
function PlayFabMultiplayerApi:GetTitleMultiplayerServersQuotas(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/GetTitleMultiplayerServersQuotas", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Join a matchmaking ticket.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/joinmatchmakingticket
--]]
function PlayFabMultiplayerApi:JoinMatchmakingTicket(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/JoinMatchmakingTicket", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists archived multiplayer server sessions for a build.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listarchivedmultiplayerservers
--]]
function PlayFabMultiplayerApi:ListArchivedMultiplayerServers(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListArchivedMultiplayerServers", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists multiplayer server game assets for a title.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listassetsummaries
--]]
function PlayFabMultiplayerApi:ListAssetSummaries(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListAssetSummaries", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists details of all build aliases for a title. Accepts tokens for title and if game client access is enabled, allows
    game client to request list of builds with player entity token.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listbuildaliases
--]]
function PlayFabMultiplayerApi:ListBuildAliases(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListBuildAliases", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists summarized details of all multiplayer server builds for a title. Accepts tokens for title and if game client
    access is enabled, allows game client to request list of builds with player entity token.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listbuildsummaries
--]]
function PlayFabMultiplayerApi:ListBuildSummaries(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListBuildSummaries", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists multiplayer server game certificates for a title.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listcertificatesummaries
--]]
function PlayFabMultiplayerApi:ListCertificateSummaries(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListCertificateSummaries", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists custom container images for a title.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listcontainerimages
--]]
function PlayFabMultiplayerApi:ListContainerImages(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListContainerImages", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists the tags for a custom container image.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listcontainerimagetags
--]]
function PlayFabMultiplayerApi:ListContainerImageTags(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListContainerImageTags", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    SDK support is limited to C# and Java for this API. List all matchmaking queue configs.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking-admin/listmatchmakingqueues
--]]
function PlayFabMultiplayerApi:ListMatchmakingQueues(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/ListMatchmakingQueues", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    List all matchmaking ticket Ids the user is a member of.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/listmatchmakingticketsforplayer
--]]
function PlayFabMultiplayerApi:ListMatchmakingTicketsForPlayer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/ListMatchmakingTicketsForPlayer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists multiplayer server sessions for a build.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listmultiplayerservers
--]]
function PlayFabMultiplayerApi:ListMultiplayerServers(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListMultiplayerServers", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists quality of service servers for party.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listpartyqosservers
--]]
function PlayFabMultiplayerApi:ListPartyQosServers(request)
    return Promise.new(function(resolve, reject)
            IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListPartyQosServers", request or {}, nil, nil, resolve, reject)
    end)
end

--[[
    Lists quality of service servers for the title. By default, servers are only returned for regions where a Multiplayer
    Servers build has been deployed.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listqosserversfortitle
--]]
function PlayFabMultiplayerApi:ListQosServersForTitle(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListQosServersForTitle", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    List all server backfill ticket Ids the user is a member of.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking/listserverbackfillticketsforplayer
--]]
function PlayFabMultiplayerApi:ListServerBackfillTicketsForPlayer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/ListServerBackfillTicketsForPlayer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Lists virtual machines for a title.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/listvirtualmachinesummaries
--]]
function PlayFabMultiplayerApi:ListVirtualMachineSummaries(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ListVirtualMachineSummaries", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    SDK support is limited to C# and Java for this API. Remove a matchmaking queue config.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking-admin/removematchmakingqueue
--]]
function PlayFabMultiplayerApi:RemoveMatchmakingQueue(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/RemoveMatchmakingQueue", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Request a multiplayer server session. Accepts tokens for title and if game client access is enabled, allows game client
    to request a server with player entity token.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/requestmultiplayerserver
--]]
function PlayFabMultiplayerApi:RequestMultiplayerServer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/RequestMultiplayerServer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Rolls over the credentials to the container registry.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/rollovercontainerregistrycredentials
--]]
function PlayFabMultiplayerApi:RolloverContainerRegistryCredentials(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/RolloverContainerRegistryCredentials", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    SDK support is limited to C# and Java for this API. Create or update a matchmaking queue configuration.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/matchmaking-admin/setmatchmakingqueue
--]]
function PlayFabMultiplayerApi:SetMatchmakingQueue(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Match/SetMatchmakingQueue", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Shuts down a multiplayer server session.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/shutdownmultiplayerserver
--]]
function PlayFabMultiplayerApi:ShutdownMultiplayerServer(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/ShutdownMultiplayerServer", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Untags a container image.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/untagcontainerimage
--]]
function PlayFabMultiplayerApi:UntagContainerImage(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/UntagContainerImage", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Creates a multiplayer server build alias.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/updatebuildalias
--]]
function PlayFabMultiplayerApi:UpdateBuildAlias(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/UpdateBuildAlias", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Updates a multiplayer server build's region. If the region is not yet created, it will be created
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/updatebuildregion
--]]
function PlayFabMultiplayerApi:UpdateBuildRegion(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/UpdateBuildRegion", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Updates a multiplayer server build's regions.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/updatebuildregions
--]]
function PlayFabMultiplayerApi:UpdateBuildRegions(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/UpdateBuildRegions", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Uploads a multiplayer server game certificate.
    https://docs.microsoft.com/rest/api/playfab/multiplayer/multiplayerserver/uploadcertificate
--]]
function PlayFabMultiplayerApi:UploadCertificate(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/MultiplayerServer/UploadCertificate", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabMultiplayerApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="15">
        <Properties>
          <string name="Name">PlayFabProfiles</string>
          <string name="Source"><![CDATA[-- PlayFab Profiles API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabProfilesApi = {
    settings = PlayFabSettings.settings
}

--[[
    Gets the global title access policy
    https://docs.microsoft.com/rest/api/playfab/profiles/account-management/getglobalpolicy
--]]
function PlayFabProfilesApi:GetGlobalPolicy(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Profile/GetGlobalPolicy", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Retrieves the entity's profile.
    https://docs.microsoft.com/rest/api/playfab/profiles/account-management/getprofile
--]]
function PlayFabProfilesApi:GetProfile(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Profile/GetProfile", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Retrieves the entity's profile.
    https://docs.microsoft.com/rest/api/playfab/profiles/account-management/getprofiles
--]]
function PlayFabProfilesApi:GetProfiles(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Profile/GetProfiles", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Retrieves the title player accounts associated with the given master player account.
    https://docs.microsoft.com/rest/api/playfab/profiles/account-management/gettitleplayersfrommasterplayeraccountids
--]]
function PlayFabProfilesApi:GetTitlePlayersFromMasterPlayerAccountIds(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Profile/GetTitlePlayersFromMasterPlayerAccountIds", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Sets the global title access policy
    https://docs.microsoft.com/rest/api/playfab/profiles/account-management/setglobalpolicy
--]]
function PlayFabProfilesApi:SetGlobalPolicy(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Profile/SetGlobalPolicy", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Updates the entity's language. The precedence hierarchy for communication to the player is Title Player Account
    language, Master Player Account language, and then title default language if the first two aren't set or supported.
    https://docs.microsoft.com/rest/api/playfab/profiles/account-management/setprofilelanguage
--]]
function PlayFabProfilesApi:SetProfileLanguage(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Profile/SetProfileLanguage", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

--[[
    Sets the profiles access policy
    https://docs.microsoft.com/rest/api/playfab/profiles/account-management/setprofilepolicy
--]]
function PlayFabProfilesApi:SetProfilePolicy(entityToken, request)
    return Promise.new(function(resolve, reject)
         if (not entityToken) then reject("Must provide an entityToken to call this method") end
        IPlayFabHttps.MakePlayFabApiCall("/Profile/SetProfilePolicy", request or {}, "X-EntityToken", entityToken, resolve, reject)
    end)
end

return PlayFabProfilesApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="16">
        <Properties>
          <string name="Name">PlayFabServer</string>
          <string name="Source"><![CDATA[-- PlayFab Server API
-- You should not require this file directly
-- All api calls are documented here: https://docs.microsoft.com/gaming/playfab/api-references/

-- Check if the roblox-ts promise implementation exists for Typescript users
local rbxts_include = game.ReplicatedStorage:FindFirstChild('rbxts_include')
local Promise
if (rbxts_include and rbxts_include:FindFirstChild('Promise')) then
    Promise = require(rbxts_include.Promise)
else
    Promise = require(script.Parent.Promise)
end

local IPlayFabHttps = require(script.Parent.IPlayFabHttps)
local PlayFabSettings = require(script.Parent.PlayFabSettings)

local PlayFabServerApi = {
    settings = PlayFabSettings.settings
}

--[[
    Increments the character's balance of the specified virtual currency by the stated amount
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/addcharactervirtualcurrency
--]]
function PlayFabServerApi:AddCharacterVirtualCurrency(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/AddCharacterVirtualCurrency", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds the Friend user to the friendlist of the user with PlayFabId. At least one of
    FriendPlayFabId,FriendUsername,FriendEmail, or FriendTitleDisplayName should be initialized.
    https://docs.microsoft.com/rest/api/playfab/server/friend-list-management/addfriend
--]]
function PlayFabServerApi:AddFriend(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/AddFriend", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds the specified generic service identifier to the player's PlayFab account. This is designed to allow for a PlayFab
    ID lookup of any arbitrary service identifier a title wants to add. This identifier should never be used as
    authentication credentials, as the intent is that it is easily accessible by other players.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/addgenericid
--]]
function PlayFabServerApi:AddGenericID(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/AddGenericID", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds a given tag to a player profile. The tag's namespace is automatically generated based on the source of the tag.
    https://docs.microsoft.com/rest/api/playfab/server/playstream/addplayertag
--]]
function PlayFabServerApi:AddPlayerTag(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/AddPlayerTag", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds users to the set of those able to update both the shared data, as well as the set of users in the group. Only users
    in the group (and the server) can add new members. Shared Groups are designed for sharing data between a very small
    number of players, please see our guide:
    https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/server/shared-group-data/addsharedgroupmembers
--]]
function PlayFabServerApi:AddSharedGroupMembers(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/AddSharedGroupMembers", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Increments the user's balance of the specified virtual currency by the stated amount
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/adduservirtualcurrency
--]]
function PlayFabServerApi:AddUserVirtualCurrency(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/AddUserVirtualCurrency", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Validated a client's session ticket, and if successful, returns details for that user
    https://docs.microsoft.com/rest/api/playfab/server/authentication/authenticatesessionticket
--]]
function PlayFabServerApi:AuthenticateSessionTicket(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/AuthenticateSessionTicket", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Awards the specified users the specified Steam achievements
    https://docs.microsoft.com/rest/api/playfab/server/platform-specific-methods/awardsteamachievement
--]]
function PlayFabServerApi:AwardSteamAchievement(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/AwardSteamAchievement", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Bans users by PlayFab ID with optional IP address, or MAC address for the provided game.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/banusers
--]]
function PlayFabServerApi:BanUsers(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/BanUsers", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Consume uses of a consumable item. When all uses are consumed, it will be removed from the player's inventory.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/consumeitem
--]]
function PlayFabServerApi:ConsumeItem(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/ConsumeItem", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Requests the creation of a shared group object, containing key/value pairs which may be updated by all members of the
    group. When created by a server, the group will initially have no members. Shared Groups are designed for sharing data
    between a very small number of players, please see our guide:
    https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/server/shared-group-data/createsharedgroup
--]]
function PlayFabServerApi:CreateSharedGroup(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/CreateSharedGroup", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Deletes the specific character ID from the specified user.
    https://docs.microsoft.com/rest/api/playfab/server/characters/deletecharacterfromuser
--]]
function PlayFabServerApi:DeleteCharacterFromUser(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/DeleteCharacterFromUser", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes a user's player account from a title and deletes all associated data
    https://docs.microsoft.com/rest/api/playfab/server/account-management/deleteplayer
--]]
function PlayFabServerApi:DeletePlayer(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/DeletePlayer", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Deletes push notification template for title
    https://docs.microsoft.com/rest/api/playfab/server/account-management/deletepushnotificationtemplate
--]]
function PlayFabServerApi:DeletePushNotificationTemplate(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/DeletePushNotificationTemplate", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Deletes a shared group, freeing up the shared group ID to be reused for a new group. Shared Groups are designed for
    sharing data between a very small number of players, please see our guide:
    https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/server/shared-group-data/deletesharedgroup
--]]
function PlayFabServerApi:DeleteSharedGroup(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/DeleteSharedGroup", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Inform the matchmaker that a Game Server Instance is removed.
    https://docs.microsoft.com/rest/api/playfab/server/matchmaking/deregistergame
--]]
function PlayFabServerApi:DeregisterGame(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/DeregisterGame", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Returns the result of an evaluation of a Random Result Table - the ItemId from the game Catalog which would have been
    added to the player inventory, if the Random Result Table were added via a Bundle or a call to UnlockContainer.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/evaluaterandomresulttable
--]]
function PlayFabServerApi:EvaluateRandomResultTable(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/EvaluateRandomResultTable", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Executes a CloudScript function, with the 'currentPlayerId' variable set to the specified PlayFabId parameter value.
    https://docs.microsoft.com/rest/api/playfab/server/server-side-cloud-script/executecloudscript
--]]
function PlayFabServerApi:ExecuteCloudScript(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/ExecuteCloudScript", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves an array of player segment definitions. Results from this can be used in subsequent API calls such as
    GetPlayersInSegment which requires a Segment ID. While segment names can change the ID for that segment will not change.
    https://docs.microsoft.com/rest/api/playfab/server/playstream/getallsegments
--]]
function PlayFabServerApi:GetAllSegments(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetAllSegments", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Lists all of the characters that belong to a specific user. CharacterIds are not globally unique; characterId must be
    evaluated with the parent PlayFabId to guarantee uniqueness.
    https://docs.microsoft.com/rest/api/playfab/server/characters/getalluserscharacters
--]]
function PlayFabServerApi:GetAllUsersCharacters(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetAllUsersCharacters", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the specified version of the title's catalog of virtual goods, including all defined properties
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/getcatalogitems
--]]
function PlayFabServerApi:GetCatalogItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetCatalogItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/server/character-data/getcharacterdata
--]]
function PlayFabServerApi:GetCharacterData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetCharacterData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user's character which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/server/character-data/getcharacterinternaldata
--]]
function PlayFabServerApi:GetCharacterInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetCharacterInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the specified character's current inventory of virtual goods
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/getcharacterinventory
--]]
function PlayFabServerApi:GetCharacterInventory(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetCharacterInventory", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked characters for the given statistic, starting from the indicated point in the leaderboard
    https://docs.microsoft.com/rest/api/playfab/server/characters/getcharacterleaderboard
--]]
function PlayFabServerApi:GetCharacterLeaderboard(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetCharacterLeaderboard", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user's character which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/server/character-data/getcharacterreadonlydata
--]]
function PlayFabServerApi:GetCharacterReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetCharacterReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the details of all title-specific statistics for the specific character
    https://docs.microsoft.com/rest/api/playfab/server/characters/getcharacterstatistics
--]]
function PlayFabServerApi:GetCharacterStatistics(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetCharacterStatistics", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    This API retrieves a pre-signed URL for accessing a content file for the title. A subsequent HTTP GET to the returned
    URL will attempt to download the content. A HEAD query to the returned URL will attempt to retrieve the metadata of the
    content. Note that a successful result does not guarantee the existence of this content - if it has not been uploaded,
    the query to retrieve the data will fail. See this post for more information:
    https://community.playfab.com/hc/community/posts/205469488-How-to-upload-files-to-PlayFab-s-Content-Service. Also,
    please be aware that the Content service is specifically PlayFab's CDN offering, for which standard CDN rates apply.
    https://docs.microsoft.com/rest/api/playfab/server/content/getcontentdownloadurl
--]]
function PlayFabServerApi:GetContentDownloadUrl(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetContentDownloadUrl", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked friends of the given player for the given statistic, starting from the indicated point in the
    leaderboard
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getfriendleaderboard
--]]
function PlayFabServerApi:GetFriendLeaderboard(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetFriendLeaderboard", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the current friends for the user with PlayFabId, constrained to users who have PlayFab accounts. Friends from
    linked accounts (Facebook, Steam) are also included. You may optionally exclude some linked services' friends.
    https://docs.microsoft.com/rest/api/playfab/server/friend-list-management/getfriendslist
--]]
function PlayFabServerApi:GetFriendsList(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetFriendsList", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked users for the given statistic, starting from the indicated point in the leaderboard
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getleaderboard
--]]
function PlayFabServerApi:GetLeaderboard(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetLeaderboard", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked characters for the given statistic, centered on the requested user
    https://docs.microsoft.com/rest/api/playfab/server/characters/getleaderboardaroundcharacter
--]]
function PlayFabServerApi:GetLeaderboardAroundCharacter(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetLeaderboardAroundCharacter", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves a list of ranked users for the given statistic, centered on the currently signed-in user
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getleaderboardarounduser
--]]
function PlayFabServerApi:GetLeaderboardAroundUser(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetLeaderboardAroundUser", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves a list of all of the user's characters for the given statistic.
    https://docs.microsoft.com/rest/api/playfab/server/characters/getleaderboardforusercharacters
--]]
function PlayFabServerApi:GetLeaderboardForUserCharacters(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetLeaderboardForUserCharacters", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Returns whatever info is requested in the response for the user. Note that PII (like email address, facebook id) may be
    returned. All parameters default to false.
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getplayercombinedinfo
--]]
function PlayFabServerApi:GetPlayerCombinedInfo(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayerCombinedInfo", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the player's profile
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getplayerprofile
--]]
function PlayFabServerApi:GetPlayerProfile(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayerProfile", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    List all segments that a player currently belongs to at this moment in time.
    https://docs.microsoft.com/rest/api/playfab/server/playstream/getplayersegments
--]]
function PlayFabServerApi:GetPlayerSegments(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayerSegments", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Allows for paging through all players in a given segment. This API creates a snapshot of all player profiles that match
    the segment definition at the time of its creation and lives through the Total Seconds to Live, refreshing its life span
    on each subsequent use of the Continuation Token. Profiles that change during the course of paging will not be reflected
    in the results. AB Test segments are currently not supported by this operation. NOTE: This API is limited to being
    called 30 times in one minute. You will be returned an error if you exceed this threshold.
    https://docs.microsoft.com/rest/api/playfab/server/playstream/getplayersinsegment
--]]
function PlayFabServerApi:GetPlayersInSegment(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayersInSegment", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the current version and values for the indicated statistics, for the local player.
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getplayerstatistics
--]]
function PlayFabServerApi:GetPlayerStatistics(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayerStatistics", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the information on the available versions of the specified statistic.
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getplayerstatisticversions
--]]
function PlayFabServerApi:GetPlayerStatisticVersions(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayerStatisticVersions", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Get all tags with a given Namespace (optional) from a player profile.
    https://docs.microsoft.com/rest/api/playfab/server/playstream/getplayertags
--]]
function PlayFabServerApi:GetPlayerTags(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayerTags", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Facebook identifiers.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getplayfabidsfromfacebookids
--]]
function PlayFabServerApi:GetPlayFabIDsFromFacebookIDs(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayFabIDsFromFacebookIDs", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Facebook Instant Games identifiers.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getplayfabidsfromfacebookinstantgamesids
--]]
function PlayFabServerApi:GetPlayFabIDsFromFacebookInstantGamesIds(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayFabIDsFromFacebookInstantGamesIds", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of generic service identifiers. A generic identifier is the
    service name plus the service-specific ID for the player, as specified by the title when the generic identifier was
    added to the player account.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getplayfabidsfromgenericids
--]]
function PlayFabServerApi:GetPlayFabIDsFromGenericIDs(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayFabIDsFromGenericIDs", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Nintendo Switch Device identifiers.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getplayfabidsfromnintendoswitchdeviceids
--]]
function PlayFabServerApi:GetPlayFabIDsFromNintendoSwitchDeviceIds(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayFabIDsFromNintendoSwitchDeviceIds", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of PlayStation Network identifiers.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getplayfabidsfrompsnaccountids
--]]
function PlayFabServerApi:GetPlayFabIDsFromPSNAccountIDs(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayFabIDsFromPSNAccountIDs", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of Steam identifiers. The Steam identifiers are the profile
    IDs for the user accounts, available as SteamId in the Steamworks Community API calls.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getplayfabidsfromsteamids
--]]
function PlayFabServerApi:GetPlayFabIDsFromSteamIDs(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayFabIDsFromSteamIDs", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the unique PlayFab identifiers for the given set of XboxLive identifiers.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getplayfabidsfromxboxliveids
--]]
function PlayFabServerApi:GetPlayFabIDsFromXboxLiveIDs(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPlayFabIDsFromXboxLiveIDs", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the key-value store of custom publisher settings
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/getpublisherdata
--]]
function PlayFabServerApi:GetPublisherData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetPublisherData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the configuration information for the specified random results tables for the title, including all ItemId
    values and weights
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/getrandomresulttables
--]]
function PlayFabServerApi:GetRandomResultTables(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetRandomResultTables", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the associated PlayFab account identifiers for the given set of server custom identifiers.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getservercustomidsfromplayfabids
--]]
function PlayFabServerApi:GetServerCustomIDsFromPlayFabIDs(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetServerCustomIDsFromPlayFabIDs", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves data stored in a shared group object, as well as the list of members in the group. The server can access all
    public and private group data. Shared Groups are designed for sharing data between a very small number of players,
    please see our guide: https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/server/shared-group-data/getsharedgroupdata
--]]
function PlayFabServerApi:GetSharedGroupData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetSharedGroupData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the set of items defined for the specified store, including all prices defined, for the specified player
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/getstoreitems
--]]
function PlayFabServerApi:GetStoreItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetStoreItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the current server time
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/gettime
--]]
function PlayFabServerApi:GetTime(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetTime", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the key-value store of custom title settings
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/gettitledata
--]]
function PlayFabServerApi:GetTitleData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetTitleData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the key-value store of custom internal title settings
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/gettitleinternaldata
--]]
function PlayFabServerApi:GetTitleInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetTitleInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title news feed, as configured in the developer portal
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/gettitlenews
--]]
function PlayFabServerApi:GetTitleNews(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetTitleNews", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the relevant details for a specified user
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getuseraccountinfo
--]]
function PlayFabServerApi:GetUserAccountInfo(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserAccountInfo", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Gets all bans for a user.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/getuserbans
--]]
function PlayFabServerApi:GetUserBans(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserBans", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getuserdata
--]]
function PlayFabServerApi:GetUserData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getuserinternaldata
--]]
function PlayFabServerApi:GetUserInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the specified user's current inventory of virtual goods
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/getuserinventory
--]]
function PlayFabServerApi:GetUserInventory(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserInventory", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the publisher-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getuserpublisherdata
--]]
function PlayFabServerApi:GetUserPublisherData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserPublisherData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the publisher-specific custom data for the user which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getuserpublisherinternaldata
--]]
function PlayFabServerApi:GetUserPublisherInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserPublisherInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the publisher-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getuserpublisherreadonlydata
--]]
function PlayFabServerApi:GetUserPublisherReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserPublisherReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Retrieves the title-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/getuserreadonlydata
--]]
function PlayFabServerApi:GetUserReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GetUserReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Grants the specified character type to the user. CharacterIds are not globally unique; characterId must be evaluated
    with the parent PlayFabId to guarantee uniqueness.
    https://docs.microsoft.com/rest/api/playfab/server/characters/grantcharactertouser
--]]
function PlayFabServerApi:GrantCharacterToUser(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GrantCharacterToUser", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds the specified items to the specified character's inventory
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/grantitemstocharacter
--]]
function PlayFabServerApi:GrantItemsToCharacter(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GrantItemsToCharacter", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds the specified items to the specified user's inventory
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/grantitemstouser
--]]
function PlayFabServerApi:GrantItemsToUser(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GrantItemsToUser", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds the specified items to the specified user inventories
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/grantitemstousers
--]]
function PlayFabServerApi:GrantItemsToUsers(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/GrantItemsToUsers", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Links the PlayStation Network account associated with the provided access code to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/server/account-management/linkpsnaccount
--]]
function PlayFabServerApi:LinkPSNAccount(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/LinkPSNAccount", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Links the custom server identifier, generated by the title, to the user's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/linkservercustomid
--]]
function PlayFabServerApi:LinkServerCustomId(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/LinkServerCustomId", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Links the Xbox Live account associated with the provided access code to the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/server/account-management/linkxboxaccount
--]]
function PlayFabServerApi:LinkXboxAccount(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/LinkXboxAccount", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Securely login a game client from an external server backend using a custom identifier for that player. Server Custom ID
    and Client Custom ID are mutually exclusive and cannot be used to retrieve the same player account.
    https://docs.microsoft.com/rest/api/playfab/server/authentication/loginwithservercustomid
--]]
function PlayFabServerApi:LoginWithServerCustomId(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/LoginWithServerCustomId", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Signs the user in using a Xbox Live Token from an external server backend, returning a session identifier that can
    subsequently be used for API calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/server/authentication/loginwithxbox
--]]
function PlayFabServerApi:LoginWithXbox(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/LoginWithXbox", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Signs the user in using an Xbox ID and Sandbox ID, returning a session identifier that can subsequently be used for API
    calls which require an authenticated user
    https://docs.microsoft.com/rest/api/playfab/server/authentication/loginwithxboxid
--]]
function PlayFabServerApi:LoginWithXboxId(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/LoginWithXboxId", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Modifies the number of remaining uses of a player's inventory item
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/modifyitemuses
--]]
function PlayFabServerApi:ModifyItemUses(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/ModifyItemUses", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Moves an item from a character's inventory into another of the users's character's inventory.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/moveitemtocharacterfromcharacter
--]]
function PlayFabServerApi:MoveItemToCharacterFromCharacter(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/MoveItemToCharacterFromCharacter", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Moves an item from a user's inventory into their character's inventory.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/moveitemtocharacterfromuser
--]]
function PlayFabServerApi:MoveItemToCharacterFromUser(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/MoveItemToCharacterFromUser", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Moves an item from a character's inventory into the owning user's inventory.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/moveitemtouserfromcharacter
--]]
function PlayFabServerApi:MoveItemToUserFromCharacter(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/MoveItemToUserFromCharacter", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Informs the PlayFab match-making service that the user specified has left the Game Server Instance
    https://docs.microsoft.com/rest/api/playfab/server/matchmaking/notifymatchmakerplayerleft
--]]
function PlayFabServerApi:NotifyMatchmakerPlayerLeft(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/NotifyMatchmakerPlayerLeft", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds the virtual goods associated with the coupon to the user's inventory. Coupons can be generated via the
    Economy->Catalogs tab in the PlayFab Game Manager.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/redeemcoupon
--]]
function PlayFabServerApi:RedeemCoupon(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RedeemCoupon", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Validates a Game Server session ticket and returns details about the user
    https://docs.microsoft.com/rest/api/playfab/server/matchmaking/redeemmatchmakerticket
--]]
function PlayFabServerApi:RedeemMatchmakerTicket(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RedeemMatchmakerTicket", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Set the state of the indicated Game Server Instance. Also update the heartbeat for the instance.
    https://docs.microsoft.com/rest/api/playfab/server/matchmaking/refreshgameserverinstanceheartbeat
--]]
function PlayFabServerApi:RefreshGameServerInstanceHeartbeat(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RefreshGameServerInstanceHeartbeat", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Inform the matchmaker that a new Game Server Instance is added.
    https://docs.microsoft.com/rest/api/playfab/server/matchmaking/registergame
--]]
function PlayFabServerApi:RegisterGame(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RegisterGame", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes the specified friend from the the user's friend list
    https://docs.microsoft.com/rest/api/playfab/server/friend-list-management/removefriend
--]]
function PlayFabServerApi:RemoveFriend(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RemoveFriend", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes the specified generic service identifier from the player's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/removegenericid
--]]
function PlayFabServerApi:RemoveGenericID(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RemoveGenericID", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Remove a given tag from a player profile. The tag's namespace is automatically generated based on the source of the tag.
    https://docs.microsoft.com/rest/api/playfab/server/playstream/removeplayertag
--]]
function PlayFabServerApi:RemovePlayerTag(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RemovePlayerTag", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Removes users from the set of those able to update the shared data and the set of users in the group. Only users in the
    group can remove members. If as a result of the call, zero users remain with access, the group and its associated data
    will be deleted. Shared Groups are designed for sharing data between a very small number of players, please see our
    guide: https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/server/shared-group-data/removesharedgroupmembers
--]]
function PlayFabServerApi:RemoveSharedGroupMembers(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RemoveSharedGroupMembers", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Submit a report about a player (due to bad bahavior, etc.) on behalf of another player, so that customer service
    representatives for the title can take action concerning potentially toxic players.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/reportplayer
--]]
function PlayFabServerApi:ReportPlayer(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/ReportPlayer", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Revoke all active bans for a user.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/revokeallbansforuser
--]]
function PlayFabServerApi:RevokeAllBansForUser(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RevokeAllBansForUser", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Revoke all active bans specified with BanId.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/revokebans
--]]
function PlayFabServerApi:RevokeBans(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RevokeBans", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Revokes access to an item in a user's inventory
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/revokeinventoryitem
--]]
function PlayFabServerApi:RevokeInventoryItem(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RevokeInventoryItem", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Revokes access for up to 25 items across multiple users and characters.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/revokeinventoryitems
--]]
function PlayFabServerApi:RevokeInventoryItems(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/RevokeInventoryItems", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Saves push notification template for title
    https://docs.microsoft.com/rest/api/playfab/server/account-management/savepushnotificationtemplate
--]]
function PlayFabServerApi:SavePushNotificationTemplate(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SavePushNotificationTemplate", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Forces an email to be sent to the registered contact email address for the user's account based on an account recovery
    email template
    https://docs.microsoft.com/rest/api/playfab/server/account-management/sendcustomaccountrecoveryemail
--]]
function PlayFabServerApi:SendCustomAccountRecoveryEmail(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SendCustomAccountRecoveryEmail", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sends an email based on an email template to a player's contact email
    https://docs.microsoft.com/rest/api/playfab/server/account-management/sendemailfromtemplate
--]]
function PlayFabServerApi:SendEmailFromTemplate(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SendEmailFromTemplate", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sends an iOS/Android Push Notification to a specific user, if that user's device has been configured for Push
    Notifications in PlayFab. If a user has linked both Android and iOS devices, both will be notified.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/sendpushnotification
--]]
function PlayFabServerApi:SendPushNotification(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SendPushNotification", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sends an iOS/Android Push Notification template to a specific user, if that user's device has been configured for Push
    Notifications in PlayFab. If a user has linked both Android and iOS devices, both will be notified.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/sendpushnotificationfromtemplate
--]]
function PlayFabServerApi:SendPushNotificationFromTemplate(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SendPushNotificationFromTemplate", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the tag list for a specified user in the friend list of another user
    https://docs.microsoft.com/rest/api/playfab/server/friend-list-management/setfriendtags
--]]
function PlayFabServerApi:SetFriendTags(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SetFriendTags", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sets the custom data of the indicated Game Server Instance
    https://docs.microsoft.com/rest/api/playfab/server/matchmaking/setgameserverinstancedata
--]]
function PlayFabServerApi:SetGameServerInstanceData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SetGameServerInstanceData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Set the state of the indicated Game Server Instance.
    https://docs.microsoft.com/rest/api/playfab/server/matchmaking/setgameserverinstancestate
--]]
function PlayFabServerApi:SetGameServerInstanceState(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SetGameServerInstanceState", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Set custom tags for the specified Game Server Instance
    https://docs.microsoft.com/rest/api/playfab/server/matchmaking/setgameserverinstancetags
--]]
function PlayFabServerApi:SetGameServerInstanceTags(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SetGameServerInstanceTags", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Sets the player's secret if it is not already set. Player secrets are used to sign API requests. To reset a player's
    secret use the Admin or Server API method SetPlayerSecret.
    https://docs.microsoft.com/rest/api/playfab/server/authentication/setplayersecret
--]]
function PlayFabServerApi:SetPlayerSecret(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SetPlayerSecret", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the key-value store of custom publisher settings
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/setpublisherdata
--]]
function PlayFabServerApi:SetPublisherData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SetPublisherData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the key-value store of custom title settings
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/settitledata
--]]
function PlayFabServerApi:SetTitleData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SetTitleData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the key-value store of custom title settings
    https://docs.microsoft.com/rest/api/playfab/server/title-wide-data-management/settitleinternaldata
--]]
function PlayFabServerApi:SetTitleInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SetTitleInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Decrements the character's balance of the specified virtual currency by the stated amount. It is possible to make a VC
    balance negative with this API.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/subtractcharactervirtualcurrency
--]]
function PlayFabServerApi:SubtractCharacterVirtualCurrency(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SubtractCharacterVirtualCurrency", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Decrements the user's balance of the specified virtual currency by the stated amount. It is possible to make a VC
    balance negative with this API.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/subtractuservirtualcurrency
--]]
function PlayFabServerApi:SubtractUserVirtualCurrency(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/SubtractUserVirtualCurrency", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Unlinks the related PSN account from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/server/account-management/unlinkpsnaccount
--]]
function PlayFabServerApi:UnlinkPSNAccount(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UnlinkPSNAccount", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Unlinks the custom server identifier from the user's PlayFab account.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/unlinkservercustomid
--]]
function PlayFabServerApi:UnlinkServerCustomId(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UnlinkServerCustomId", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Unlinks the related Xbox Live account from the user's PlayFab account
    https://docs.microsoft.com/rest/api/playfab/server/account-management/unlinkxboxaccount
--]]
function PlayFabServerApi:UnlinkXboxAccount(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UnlinkXboxAccount", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Opens a specific container (ContainerItemInstanceId), with a specific key (KeyItemInstanceId, when required), and
    returns the contents of the opened container. If the container (and key when relevant) are consumable (RemainingUses >
    0), their RemainingUses will be decremented, consistent with the operation of ConsumeItem.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/unlockcontainerinstance
--]]
function PlayFabServerApi:UnlockContainerInstance(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UnlockContainerInstance", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Searches Player or Character inventory for any ItemInstance matching the given CatalogItemId, if necessary unlocks it
    using any appropriate key, and returns the contents of the opened container. If the container (and key when relevant)
    are consumable (RemainingUses > 0), their RemainingUses will be decremented, consistent with the operation of
    ConsumeItem.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/unlockcontaineritem
--]]
function PlayFabServerApi:UnlockContainerItem(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UnlockContainerItem", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Update the avatar URL of the specified player
    https://docs.microsoft.com/rest/api/playfab/server/account-management/updateavatarurl
--]]
function PlayFabServerApi:UpdateAvatarUrl(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateAvatarUrl", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates information of a list of existing bans specified with Ban Ids.
    https://docs.microsoft.com/rest/api/playfab/server/account-management/updatebans
--]]
function PlayFabServerApi:UpdateBans(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateBans", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user's character which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/server/character-data/updatecharacterdata
--]]
function PlayFabServerApi:UpdateCharacterData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateCharacterData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user's character which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/server/character-data/updatecharacterinternaldata
--]]
function PlayFabServerApi:UpdateCharacterInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateCharacterInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user's character which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/server/character-data/updatecharacterreadonlydata
--]]
function PlayFabServerApi:UpdateCharacterReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateCharacterReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the values of the specified title-specific statistics for the specific character
    https://docs.microsoft.com/rest/api/playfab/server/characters/updatecharacterstatistics
--]]
function PlayFabServerApi:UpdateCharacterStatistics(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateCharacterStatistics", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the values of the specified title-specific statistics for the user
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/updateplayerstatistics
--]]
function PlayFabServerApi:UpdatePlayerStatistics(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdatePlayerStatistics", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Adds, updates, and removes data keys for a shared group object. If the permission is set to Public, all fields updated
    or added in this call will be readable by users not in the group. By default, data permissions are set to Private.
    Regardless of the permission setting, only members of the group (and the server) can update the data. Shared Groups are
    designed for sharing data between a very small number of players, please see our guide:
    https://docs.microsoft.com/gaming/playfab/features/social/groups/using-shared-group-data
    https://docs.microsoft.com/rest/api/playfab/server/shared-group-data/updatesharedgroupdata
--]]
function PlayFabServerApi:UpdateSharedGroupData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateSharedGroupData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/updateuserdata
--]]
function PlayFabServerApi:UpdateUserData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateUserData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/updateuserinternaldata
--]]
function PlayFabServerApi:UpdateUserInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateUserInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the key-value pair data tagged to the specified item, which is read-only from the client.
    https://docs.microsoft.com/rest/api/playfab/server/player-item-management/updateuserinventoryitemcustomdata
--]]
function PlayFabServerApi:UpdateUserInventoryItemCustomData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateUserInventoryItemCustomData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the publisher-specific custom data for the user which is readable and writable by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/updateuserpublisherdata
--]]
function PlayFabServerApi:UpdateUserPublisherData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateUserPublisherData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the publisher-specific custom data for the user which cannot be accessed by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/updateuserpublisherinternaldata
--]]
function PlayFabServerApi:UpdateUserPublisherInternalData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateUserPublisherInternalData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the publisher-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/updateuserpublisherreadonlydata
--]]
function PlayFabServerApi:UpdateUserPublisherReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateUserPublisherReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Updates the title-specific custom data for the user which can only be read by the client
    https://docs.microsoft.com/rest/api/playfab/server/player-data-management/updateuserreadonlydata
--]]
function PlayFabServerApi:UpdateUserReadOnlyData(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/UpdateUserReadOnlyData", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Writes a character-based event into PlayStream.
    https://docs.microsoft.com/rest/api/playfab/server/analytics/writecharacterevent
--]]
function PlayFabServerApi:WriteCharacterEvent(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/WriteCharacterEvent", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Writes a player-based event into PlayStream.
    https://docs.microsoft.com/rest/api/playfab/server/analytics/writeplayerevent
--]]
function PlayFabServerApi:WritePlayerEvent(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/WritePlayerEvent", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

--[[
    Writes a title-based event into PlayStream.
    https://docs.microsoft.com/rest/api/playfab/server/analytics/writetitleevent
--]]
function PlayFabServerApi:WriteTitleEvent(request)
    return Promise.new(function(resolve, reject)
         if (not PlayFabSettings.settings.titleId or not PlayFabSettings.settings.devSecretKey) then
            reject("Must have PlayFabSettings.settings.devSecretKey set to call this method")
        end
        IPlayFabHttps.MakePlayFabApiCall("/Server/WriteTitleEvent", request or {}, "X-SecretKey", PlayFabSettings.settings.developerSecretKey, resolve, reject)
    end)
end

return PlayFabServerApi
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="17">
        <Properties>
          <string name="Name">PlayFabSettings</string>
          <string name="Source">-- Holds the basic settings for PlayFab
-- PlayFabSettings.settings is public and contains the following:
--     titleId -- You must set this before making any PlayFab API calls
--     devSecretKey -- Server/Admin only, required for any non-client call

local PlayFabSettings = {
    _internalSettings = {
        sdkVersionString = "RobloxSdk_undefined",
        buildIdentifier = "default_manual_build",
        requestGetParams = {["sdk"] = "RobloxSdk_undefined"}
    },
    settings = {
        titleId = nil,
        devSecretKey = nil,

        -- Probably don't need to edit
        productionUrl = ".playfabapi.com",
        verticalName = nil -- The name of a customer vertical. This is only for customers running a private cluster. Generally you shouldn't touch this
    }
}

return PlayFabSettings</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="18">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = {__mode = "k"}

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.
]]
local Error do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(errorStrings, table.concat({
				runtimeError.trace or runtimeError.error,
				runtimeError.context,
			}, "\n"))
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end


local function makeErrorHandler(traceback)
	assert(traceback ~= nil)

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", {"Started", "Resolved", "Rejected", "Cancelled"}),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
}
Promise.prototype = {}
Promise.__index = Promise.prototype

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(
			self._source,
			callback,
			resolve,
			reject,
			onCancel
		)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self:getStatus())
end

--[[
	Promise.new, except pcall on a new thread is automatic.
]]
function Promise.defer(callback)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, callback, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[[
	Begins a Promise chain, turning synchronous errors into rejections.
]]
function Promise.try(...)
	return Promise._try(debug.traceback(nil, 2), ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					rejectedCount = rejectedCount + 1

					if amount == nil or #promises - rejectedCount < amount then
						cancel()
						done = true

						reject(...)
					end
				end
			)
		end

		if done then
			cancel()
		end
	end)
end

function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

function Promise.some(promises, amount)
	assert(type(amount) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, amount)
end

function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(
				function(...)
					resolveOne(i, ...)
				end
			)
		end
	end)
end

--[[
	Races a set of Promises and returns the first one that resolves,
	cancelling the others.
]]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function (...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[[
	Iterates serially over the given an array of values, calling the predicate callback on each before continuing.
	If the predicate returns a Promise, we wait for that Promise to resolve before continuing to the next item
	in the array. If the Promise the predicate returns rejects, the Promise from Promise.each is also rejected with
	the same value.

	Returns a Promise containing an array of the return values from the predicate for each item in the original list.
]]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(type(predicate) == "function", string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return type(object.andThen) == "function"
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and type(rawget(rawget(objectMetatable, "__index"), "andThen")) == "function"
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[[
	Converts a yielding function into a Promise-returning one.
]]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[[
	Creates a Promise that resolves after given number of seconds.
]]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[[
	Rejects the promise after `seconds` seconds.
]]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(
				traceback,
				successHandler,
				resolve,
				reject
			)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(
				traceback,
				failureHandler,
				resolve,
				reject
			)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

function Promise.prototype:andThen(successHandler, failureHandler)
	assert(
		successHandler == nil or type(successHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)
	assert(
		failureHandler == nil or type(failureHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:andThen")
	)

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	assert(
		failureCallback == nil or type(failureCallback) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:catch")
	)
	return self:_andThen(debug.traceback(nil, 2), nil, failureCallback)
end

--[[
	Like andThen, but the value passed into the handler is also the
	value returned from the handler.
]]
function Promise.prototype:tap(tapCallback)
	assert(type(tapCallback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapCallback(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[[
	Calls a callback on `andThen` with specific arguments.
]]
function Promise.prototype:andThenCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for an andThen handler that returns the given value.
]]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(
				traceback,
				finallyHandler,
				resolve,
				reject
			)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

function Promise.prototype:finally(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:finally")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[[
	Calls a callback on `finally` with specific arguments.
]]
function Promise.prototype:finallyCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[[
	Shorthand for a finally handler that returns the given value.
]]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[[
	Similar to finally, except rejections are propagated through it.
]]
function Promise.prototype:done(finallyHandler)
	assert(
		finallyHandler == nil or type(finallyHandler) == "function",
		string.format(ERROR_NON_FUNCTION, "Promise:done")
	)
	return self:_finally(debug.traceback(nil, 2), finallyHandler, true)
end

--[[
	Calls a callback on `done` with specific arguments.
]]
function Promise.prototype:doneCall(callback, ...)
	assert(type(callback) == "function", string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[[
	Shorthand for a done handler that returns the given value.
]]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[[
	Calls awaitStatus internally, returns (isResolved, values...)
]]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[[
	Calls await and only returns if the Promise resolves.
	Throws if the Promise rejects or gets cancelled.
]]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				local maybeRuntimeError = chainedPromise._values[1]

				-- Backwards compatibility < v2
				if chainedPromise._error then
					maybeRuntimeError = Error.new({
						error = chainedPromise._error,
						kind = Error.Kind.ExecutionError,
						context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
					})
				end

				if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
					return self:_reject(maybeRuntimeError:extend({
						error = "This Promise was chained to a Promise that errored.",
						trace = "",
						context = string.format(
							"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
							self._source
						),
					}))
				end

				self:_reject(...)
			end
		)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format(
				"Unhandled Promise rejection:\n\n%s\n\n%s",
				err,
				self._source
			)

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[[
	Chains a Promise from this one that is resolved if this Promise is
	resolved, and rejected if it is not resolved.
]]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self:getStatus() == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[[
	Retries a Promise-returning callback N times until it succeeds.
]]
function Promise.retry(callback, times, ...)
	assert(type(callback) == "function", "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = {...}, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[[
	Converts an event into a Promise with an optional predicate
]]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(function()
			disconnect()
		end)
	end)
end

return Promise
]]></string>
        </Properties>
      </Item>
    </Item>
    <Item class="Folder" referent="19">
      <Properties>
        <string name="Name">rbxts_include</string>
      </Properties>
      <Item class="ModuleScript" referent="20">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
	Forked from LPGhatguy/roblox-lua-promise, modified for roblox-ts.
]]

local PROMISE_DEBUG = false

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	local len = select("#", ...)

	return len, { ... }
end

--[[
	wpcallPacked is a version of xpcall that:
	* Returns the length of the result first
	* Returns the result packed into a table
	* Passes extra arguments through to the passed function; xpcall doesn't
	* Issues a warning if PROMISE_DEBUG is enabled
]]
local function wpcallPacked(f, ...)
	local argsLength, args = pack(...)

	local body = function()
		return f(unpack(args, 1, argsLength))
	end

	local resultLength, result = pack(xpcall(body, debug.traceback))

	-- If promise debugging is on, warn whenever a pcall fails.
	-- This is useful for debugging issues within the Promise implementation
	-- itself.
	if PROMISE_DEBUG and not result[1] then
		warn(result[2])
	end

	return resultLength, result
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(callback, resolve, reject)
	return function(...)
		local resultLength, result = wpcallPacked(callback, ...)
		local ok = result[1]

		if ok then
			resolve(unpack(result, 2, resultLength))
		else
			reject(unpack(result, 2, resultLength))
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

local function createSymbol(name)
	assert(type(name) == "string", "createSymbol requires `name` to be a string.")

	local symbol = newproxy(true)

	getmetatable(symbol).__tostring = function()
		return ("Symbol(%s)"):format(name)
	end

	return symbol
end

local PromiseMarker = createSymbol("PromiseMarker")

local Promise = {}
Promise.prototype = {}
Promise.__index = Promise.prototype

Promise.Status = {
	Started = createSymbol("Started"),
	Resolved = createSymbol("Resolved"),
	Rejected = createSymbol("Rejected"),
	Cancelled = createSymbol("Cancelled"),
}

--[[
	Constructs a new Promise with the given initializing callback.

	This is generally only called when directly wrapping a non-promise API into
	a promise-based version.

	The callback will receive 'resolve' and 'reject' methods, used to start
	invoking the promise chain.

	For example:

		local function get(url)
			return Promise.new(function(resolve, reject)
				spawn(function()
					resolve(HttpService:GetAsync(url))
				end)
			end)
		end

		get("https://google.com")
			:andThen(function(stuff)
				print("Got some stuff!", stuff)
			end)

	Second parameter, parent, is used internally for tracking the "parent" in a
	promise chain. External code shouldn't need to worry about this.
]]
function Promise.new(callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = debug.traceback(),

		-- A tag to identify us as a promise
		[PromiseMarker] = true,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- If an error occurs with no observers, this will be set.
		_unhandledRejection = false,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation.
		_parent = parent,

		-- The number of consumers attached to this promise. This is needed so that
		-- we don't propagate promise cancellations when there are still uncancelled
		-- consumers.
		_numConsumers = 0,
	}

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		assert(type(cancellationHook) == "function", "onCancel must be called with a function as its first argument.")

		if self._status == Promise.Status.Cancelled then
			cancellationHook()
		else
			self._cancellationHook = cancellationHook
		end
	end

	local _, result = wpcallPacked(callback, resolve, reject, onCancel)
	local ok = result[1]
	local err = result[2]

	if not ok and self._status == Promise.Status.Started then
		reject(err)
	end

	return self
end

--[[
	Fast spawn: Spawns a thread with predictable timing.
	Runs immediately instead of first cycle being deferred.
]]
function Promise.spawn(callback, ...)
	local spawnBindable = Instance.new("BindableEvent")
	local args = { ... }
	local length = select("#", ...)
	spawnBindable.Event:Connect(function()
		callback(unpack(args, 1, length))
	end)
	spawnBindable:Fire()
	spawnBindable:Destroy()
end

--[[
	Create a promise that represents the immediately resolved value.
]]
function Promise.resolve(value)
	return Promise.new(function(resolve)
		resolve(value)
	end)
end

--[[
	Create a promise that represents the immediately rejected value.
]]
function Promise.reject(value)
	return Promise.new(function(_, reject)
		reject(value)
	end)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise.all(promises)
	if type(promises) ~= "table" then
		error("Please pass a list of promises to Promise.all", 2)
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i = 1, #promises do
		if not Promise.is(promises[i]) then
			error(("Non-promise value passed into Promise.all at index #%d"):format(i), 2)
		end
	end

	return Promise.new(function(resolve, reject)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			resolvedValues[i] = ...
			resolvedCount = resolvedCount + 1

			if resolvedCount == #promises then
				resolve(resolvedValues)
			end
		end

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i = 1, #promises do
			promises[i]:andThen(
				function(...)
					resolveOne(i, ...)
				end,
				function(...)
					reject(...)
				end
			)
		end
	end)
end

--[[
	Is the given object a Promise instance?
]]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	return object[PromiseMarker] == true
end

function Promise.prototype:getStatus()
	return self._status
end

function Promise.prototype:isRejected()
	return self._status == Promise.Status.Rejected
end

function Promise.prototype:isResolved()
	return self._status == Promise.Status.Resolved
end

function Promise.prototype:isPending()
	return self._status == Promise.Status.Started
end

function Promise.prototype:isCancelled()
	return self._status == Promise.Status.Cancelled
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:andThen(successHandler, failureHandler)
	self._unhandledRejection = false
	self._numConsumers = self._numConsumers + 1

	-- Create a new promise to follow this part of the chain
	return Promise.new(function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject("Promise is cancelled")
		end
	end, self)
end

--[[
	Used to catch any errors that may have occurred in the promise.
]]
function Promise.prototype:catch(failureCallback)
	return self:andThen(nil, failureCallback)
end

--[[
	Cancels the promise, disallowing it from rejecting or resolving, and calls
	the cancellation hook if provided.
]]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled()
	self._numConsumers = self._numConsumers - 1

	if self._numConsumers <= 0 then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:finally(finallyHandler)
	self._numConsumers = self._numConsumers + 1

	-- Return a promise chained off of this promise
	return Promise.new(function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(finallyHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback()
		end
	end, self)
end

--[[
	Yield until the promise is completed.

	This matches the execution model of normal Roblox functions.
]]
function Promise.prototype:await()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local result
		local resultLength
		local bindable = Instance.new("BindableEvent")

		self:andThen(
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(true)
			end,
			function(...)
				resultLength, result = pack(...)
				bindable:Fire(false)
			end
		)
		self:finally(function()
			bindable:Fire(nil)
		end)

		local ok = bindable.Event:Wait()
		bindable:Destroy()

		if ok == nil then
			-- If cancelled, we return nil.
			return nil
		end

		return ok, unpack(result, 1, resultLength)
	elseif self._status == Promise.Status.Resolved then
		return true, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return false, unpack(self._values, 1, self._valuesLength)
	end

	-- If the promise is cancelled, fall through to nil.
	return nil
end

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = (
				"When returning a Promise from andThen, extra arguments are " ..
				"discarded! See:\n\n%s"
			):format(
				self._source
			)
			warn(message)
		end

		(...):andThen(
			function(...)
				self:_resolve(...)
			end,
			function(...)
				self:_reject(...)
			end
		)

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		callback(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			callback(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		self._unhandledRejection = true
		local err = tostring((...))

		spawn(function()
			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = ("Unhandled promise rejection:\n\n%s\n\n%s"):format(
				err,
				self._source
			)
			warn(message)
		end)
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		callback()
	end
end

return Promise
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="21">
        <Properties>
          <string name="Name">RuntimeLib</string>
          <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")
local ReplicatedFirst = game:GetService("ReplicatedFirst")

local TS = {}

-- runtime classes
TS.Promise = Promise

local Symbol do
	Symbol = {}
	Symbol.__index = Symbol
	setmetatable(Symbol, {
		__call = function(_, description)
			local self = setmetatable({}, Symbol)
			self.description = "Symbol(" .. (description or "") .. ")"
			return self
		end
	})

	local symbolRegistry = setmetatable({}, {
		__index = function(self, k)
			self[k] = Symbol(k)
			return self[k]
		end
	})

	function Symbol:toString()
		return self.description
	end

	Symbol.__tostring = Symbol.toString

	-- Symbol.for
	function Symbol.getFor(key)
		return symbolRegistry[key]
	end

	function Symbol.keyFor(goalSymbol)
		for key, symbol in pairs(symbolRegistry) do
			if symbol == goalSymbol then
				return key
			end
		end
	end
end

TS.Symbol = Symbol
TS.Symbol_iterator = Symbol("Symbol.iterator")

local function isPlugin(object)
	return RunService:IsStudio() and object:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

-- module resolution
function TS.getModule(object, moduleName)
	if RunService:IsRunning() and object:IsDescendantOf(ReplicatedFirst) then
		warn("roblox-ts packages should not be used from ReplicatedFirst!")
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(object) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local globalModules = script.Parent:FindFirstChild("node_modules")
	if not globalModules then
		error("Could not find any modules!", 2)
	end

	repeat
		local modules = object:FindFirstChild("node_modules")
		if modules then
			local module = modules:FindFirstChild(moduleName)
			if module then
				return module
			end
		end
		object = object.Parent
	until object == nil or object == globalModules

	return globalModules:FindFirstChild(moduleName) or error("Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(caller, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error("Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[caller] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "   " .. currentModule.Name
			end

			error("Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error("Invalid module access! Do you have two TS runtimes trying to import this? " .. module:GetFullName(), 2)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[caller] == module then -- Thread-safe cleanup!
		currentlyLoading[caller] = nil
	end

	return data
end

function TS.exportNamespace(module, ancestor)
	for key, value in pairs(module) do
		ancestor[key] = value
	end
end

-- general utility functions
function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

local function package(...)
	return select("#", ...), {...}
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local size, result = package(promise:await())
	local ok = table.remove(result, 1)
	if ok then
		if size > 2 then
			return result
		else
			return result[1]
		end
	else
		error(ok == nil and "The awaited Promise was cancelled" or (size > 2 and result[1] or result), 2)
	end
end

function TS.add(a, b)
	if type(a) == "string" or type(b) == "string" then
		return a .. b
	else
		return a + b
	end
end

function TS.bit_lrsh(a, b)
	local absA = math.abs(a)
	local result = bit32.rshift(absA, b)
	if a == absA then
		return result
	else
		return -result - 1
	end
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

-- LEGACY RUNTIME FUNCTIONS

local HttpService = game:GetService("HttpService")

function TS.generator(c)
	c = coroutine.create(c)

	local o = {
		next = function(...)
			if coroutine.status(c) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(c, ...)
				if success == false then error(value, 2) end
				return { value = value, done = coroutine.status(c) == "dead" }
			end
		end
	}

	o[TS.Symbol_iterator] = function() return o end

	return o
end

-- utility functions
local function copy(object)
	local result = {}
	for k, v in pairs(object) do
		result[k] = v
	end
	return result
end

local function deepCopyHelper(object, encountered)
	local result = {}
	encountered[object] = result

	for k, v in pairs(object) do
		if type(k) == "table" then
			k = encountered[k] or deepCopyHelper(k, encountered)
		end

		if type(v) == "table" then
			v = encountered[v] or deepCopyHelper(v, encountered)
		end

		result[k] = v
	end

	return result
end

local function deepCopy(object)
	return deepCopyHelper(object, {})
end

local function deepEquals(a, b)
	-- a[k] == b[k]
	for k in pairs(a) do
		local av = a[k]
		local bv = b[k]
		if type(av) == "table" and type(bv) == "table" then
			local result = deepEquals(av, bv)
			if not result then
				return false
			end
		elseif av ~= bv then
			return false
		end
	end

	-- extra keys in b
	for k in pairs(b) do
		if a[k] == nil then
			return false
		end
	end

	return true
end

-- Object static functions

function TS.Object_keys(object)
	local result = {}
	for key in pairs(object) do
		result[#result + 1] = key
	end
	return result
end

function TS.Object_values(object)
	local result = {}
	for _, value in pairs(object) do
		result[#result + 1] = value
	end
	return result
end

function TS.Object_entries(object)
	local result = {}
	for key, value in pairs(object) do
		result[#result + 1] = { key, value }
	end
	return result
end

function TS.Object_assign(toObj, ...)
	for i = 1, select("#", ...) do
		local arg = select(i, ...)
		if type(arg) == "table" then
			for key, value in pairs(arg) do
				toObj[key] = value
			end
		end
	end
	return toObj
end

TS.Object_copy = copy

TS.Object_deepCopy = deepCopy

TS.Object_deepEquals = deepEquals

local function toString(data)
	return HttpService:JSONEncode(data)
end

TS.Object_toString = toString

-- string macro functions
function TS.string_find_wrap(a, b, ...)
	if a then
		return a - 1, b - 1, ...
	end
end

-- array macro functions
local function array_copy(list)
	local result = {}
	for i = 1, #list do
		result[i] = list[i]
	end
	return result
end

TS.array_copy = array_copy

function TS.array_entries(list)
	local result = {}
	for key = 1, #list do
		result[key] = { key - 1, list[key] }
	end
	return result
end

function TS.array_forEach(list, callback)
	for i = 1, #list do
		callback(list[i], i - 1, list)
	end
end

local function array_map(list, callback)
	local result = {}
	for i = 1, #list do
		result[i] = callback(list[i], i - 1, list)
	end
	return result
end

TS.array_map = array_map

function TS.array_mapFiltered(list, callback)
    local new = {}
    local index = 1

    for i = 1, #list do
        local result = callback(list[i], i - 1, list)

        if result ~= nil then
            new[index] = result
            index = index + 1
        end
    end

    return new
end

local function getArraySizeSlow(list)
    local result = 0
    for index in pairs(list) do
        if index > result then
            result = index
        end
    end
    return result
end

function TS.array_filterUndefined(list)
	local length = 0
	local result = {}
	for i = 1, getArraySizeSlow(list) do
		local value = list[i]
		if value ~= nil then
			length = length + 1
			result[length] = value
		end
	end
	return result
end

function TS.array_filter(list, callback)
	local result = {}
	for i = 1, #list do
		local v = list[i]
		if callback(v, i - 1, list) == true then
			result[#result + 1] = v
		end
	end
	return result
end

function TS.array_sort(list, callback)
	table.sort(list, callback)
	return list
end

TS.array_toString = toString

function TS.array_slice(list, startI, endI)
	local length = #list

	if startI == nil then startI = 0 end
	if endI == nil then endI = length end

	if startI < 0 then startI = length + startI end
	if endI < 0 then endI = length + endI end

	local result = {}

	for i = startI + 1, endI do
		result[i - startI] = list[i]
	end

	return result
end

function TS.array_splice(list, start, deleteCount, ...)
	local len = #list
	local actualStart
	if start < 0 then
		actualStart = len + start
		if actualStart < 0 then
			actualStart = 0
		end
	else
		if start < len then
			actualStart = start
		else
			actualStart = len
		end
	end
	local items = { ... }
	local itemCount = #items
	local actualDeleteCount
	if start == nil then
		actualDeleteCount = 0
	elseif deleteCount == nil then
		actualDeleteCount = len - actualStart
	else
		if deleteCount < 0 then
			deleteCount = 0
		end
		actualDeleteCount = len - actualStart
		if deleteCount < actualDeleteCount then
			actualDeleteCount = deleteCount
		end
	end
	local out = {}
	local k = 0
	while k < actualDeleteCount do
		local from = actualStart + k
		if list[from + 1] then
			out[k + 1] = list[from + 1]
		end
		k = k + 1
	end
	if itemCount < actualDeleteCount then
		k = actualStart
		while k < len - actualDeleteCount do
			local from = k + actualDeleteCount
			local to = k + itemCount
			if list[from + 1] then
				list[to + 1] = list[from + 1]
			else
				list[to + 1] = nil
			end
			k = k + 1
		end
		k = len
		while k > len - actualDeleteCount + itemCount do
			list[k] = nil
			k = k - 1
		end
	elseif itemCount > actualDeleteCount then
		k = len - actualDeleteCount
		while k > actualStart do
			local from = k + actualDeleteCount
			local to = k + itemCount
			if list[from] then
				list[to] = list[from]
			else
				list[to] = nil
			end
			k = k - 1
		end
	end
	k = actualStart
	for i = 1, #items do
		list[k + 1] = items[i]
		k = k + 1
	end
	k = #list
	while k > len - actualDeleteCount + itemCount do
		list[k] = nil
		k = k - 1
	end
	return out
end

function TS.array_some(list, callback)
	for i = 1, #list do
		if callback(list[i], i - 1, list) == true then
			return true
		end
	end
	return false
end

function TS.array_every(list, callback)
	for i = 1, #list do
		if not callback(list[i], i - 1, list) then
			return false
		end
	end
	return true
end

function TS.array_includes(list, item, startingIndex)
	for i = (startingIndex or 0) + 1, #list do
		if list[i] == item then
			return true
		end
	end
	return false
end

function TS.array_indexOf(list, value, fromIndex)
	for i = (fromIndex or 0) + 1, #list do
		if value == list[i] then
			return i - 1
		end
	end
	return -1
end

function TS.array_lastIndexOf(list, value, fromIndex)
	for i = (fromIndex or #list - 1) + 1, 1, -1 do
		if value == list[i] then
			return i - 1
		end
	end
	return -1
end

function TS.array_reverse(list)
	local result = {}
	local length = #list
	local n = length + 1
	for i = 1, length do
		result[i] = list[n - i]
	end
	return result
end

function TS.array_reduce(list, callback, ...)
	local first = 1
	local last = #list
	local accumulator
	-- support `nil` initialValues
	if select("#", ...) == 0 then
		if last == 0 then
			error("Reduce of empty array with no initial value at Array.reduce", 2)
		end
		accumulator = list[first]
		first = first + 1
	else
		accumulator = ...
	end
	for i = first, last do
		accumulator = callback(accumulator, list[i], i - 1, list)
	end
	return accumulator
end

function TS.array_reduceRight(list, callback, ...)
	local first = #list
	local last = 1
	local accumulator
	-- support `nil` initialValues
	if select("#", ...) == 0 then
		if first == 0 then
			error("Reduce of empty array with no initial value at Array.reduceRight", 2)
		end
		accumulator = list[first]
		first = first - 1
	else
		accumulator = ...
	end
	for i = first, last, -1 do
		accumulator = callback(accumulator, list[i], i - 1, list)
	end
	return accumulator
end

function TS.array_unshift(list, ...)
	local n = #list
	local argsLength = select("#", ...)
	for i = n, 1, -1 do
		list[i + argsLength] = list[i]
	end
	for i = 1, argsLength do
		list[i] = select(i, ...)
	end
	return n + argsLength
end

local function array_push_apply(list, ...)
	local len = #list
	for i = 1, select("#", ...) do
		local list2 = select(i, ...)
		local len2 = #list2
		for j = 1, len2 do
			list[len + j] = list2[j]
		end
		len = len + len2
	end
	return len
end

TS.array_push_apply = array_push_apply

function TS.array_push_stack(list, ...)
	local len = #list
	local len2 = select("#", ...)
	for i = 1, len2 do
		list[len + i] = select(i, ...)
	end
	return len + len2
end

function TS.array_concat(...)
	local result = {}
	array_push_apply(result, ...)
	return result
end

function TS.array_join(list, separator)
	return table.concat(array_map(list, tostring), separator or ",")
end

function TS.array_find(list, callback)
	for i = 1, #list do
		local v = list[i]
		if callback(v, i - 1, list) == true then
			return v
		end
	end
end

function TS.array_findIndex(list, callback)
	for i = 0, #list - 1 do
		if callback(list[i + 1], i, list) == true then
			return i
		end
	end
	return -1
end

local function array_flat_helper(list, depth, count, result)
	for i = 1, #list do
		local v = list[i]

		if type(v) == "table" and depth ~= 0 then
			count = array_flat_helper(v, depth - 1, count, result)
		else
			count = count + 1
			result[count] = v
		end
	end

	return count
end

function TS.array_flat(list, depth)
	local result = {}
	array_flat_helper(list, depth or 1, 0, result)
	return result
end

function TS.array_fill(list, value, from, to)
	local length = #list

	if from == nil then
		from = 0
	elseif from < 0 then
		from = from + length
	end

	if to == nil or to > length then
		to = length
	elseif to < 0 then
		to = to + length
	end

	for i = from + 1, to do
		list[i] = value
	end

	return list
end

function TS.array_copyWithin(list, target, from, to)
	local length = #list

	if target < 0 then
		target = target + length
	end

	if from == nil then
		from = 0
	elseif from < 0 then
		from = from + length
	end

	if to == nil or to > length then
		to = length
	elseif to < 0 then
		to = to + length
	end

	local tf = target - from
	local overshoot = to + tf - length

	if overshoot > 0 then
		to = from + length - target
	end

	for i = to, from + 1, -1 do
		list[i + tf] = list[i]
	end

	return list
end

TS.array_deepCopy = deepCopy

TS.array_deepEquals = deepEquals

-- map macro functions

function TS.map_new(pairs)
	local result = {}
	if pairs then
		for i = 1, #pairs do
			local pair = pairs[i]
			result[pair[1]] = pair[2]
		end
	end
	return result
end

TS.Object_fromEntries = TS.map_new

function TS.map_clear(map)
	for key in pairs(map) do
		map[key] = nil
	end
end

local function getNumKeys(map)
	local result = 0
	for _ in pairs(map) do
		result = result + 1
	end
	return result
end

TS.map_size = getNumKeys
TS.map_entries = TS.Object_entries

function TS.map_forEach(map, callback)
	for key, value in pairs(map) do
		callback(value, key, map)
	end
end

TS.map_keys = TS.Object_keys

TS.map_values = TS.Object_values
TS.map_toString = toString

-- set macro functions

function TS.set_new(values)
	local result = {}
	if values then
		for i = 1, #values do
			result[values[i]] = true
		end
	end
	return result
end

TS.set_clear = TS.map_clear

function TS.set_forEach(set, callback)
	for key in pairs(set) do
		callback(key, key, set)
	end
end

function TS.set_union(set1, set2)
	local result = {}

	for value in pairs(set1) do
		result[value] = true
	end

	for value in pairs(set2) do
		result[value] = true
	end

	return result
end

function TS.set_intersect(set1, set2)
	local result = {}

	for value in pairs(set1) do
		if set2[value] then
			result[value] = true
		end
	end

	return result
end

function TS.set_isDisjointWith(set1, set2)
	for value in pairs(set1) do
		if set2[value] then
			return false
		end
	end
	return true
end

function TS.set_isSubsetOf(set1, set2)
	for value in pairs(set1) do
		if set2[value] == nil then
			return false
		end
	end

	return true
end

function TS.set_difference(set1, set2)
	local result = {}
	for value in pairs(set1) do
		if set2[value] == nil then
			result[value] = true
		end
	end
	return result
end

TS.set_values = TS.Object_keys

TS.set_size = getNumKeys

TS.set_toString = toString

function TS.string_startsWith(str1, str2, pos)
	local n1 = #str1
	local n2 = #str2

	if pos == nil or pos ~= pos then
		pos = 0
	else
		pos = math.clamp(pos, 0, n1)
	end

	local last = pos + n2;
	return last <= n1 and string.sub(str1, pos + 1, last) == str2
end

function TS.string_endsWith(str1, str2, pos)
	local n1 = #str1
	local n2 = #str2

	if pos == nil then
		pos = n1
	elseif pos ~= pos then
		pos = 0
	else
		pos = math.clamp(pos, 0, n1)
	end

	local start = pos - n2 + 1;
	return start > 0 and string.sub(str1, start, pos) == str2
end

-- spread cache functions
function TS.string_spread(str)
	local results = {}
	local count = 0
	for char in string.gmatch(str, "[%z\1-\127\194-\244][\128-\191]*") do
		count = count + 1
		results[count] = char
	end
	return results
end

function TS.iterableCache(iter)
	local results = {}
	local count = 0
	for _0 in iter.next do
		if _0.done then break end
		count = count + 1
		results[count] = _0.value
	end
	return results
end

function TS.iterableFunctionCache(iter)
	local results = {}
	local count = 0

	while true do
		local size, t = package(iter());
		if size == 0 then break end
		count = count + 1
		results[count] = t
	end

	return results
end

-- roact functions

function TS.Roact_combine(...)
	local args = { ... }
	local result = {}
	for i = 1, #args do
		for key, value in pairs(args[i]) do
			if (type(key) == "number") then
				table.insert(result, value)
			else
				result[key] = value
			end
		end
	end
	return result
end

-- opcall

function TS.opcall(func, ...)
	local success, valueOrErr = pcall(func, ...)
	if success then
		return {
			success = true,
			value = valueOrErr,
		}
	else
		return {
			success = false,
			error = valueOrErr,
		}
	end
end

return TS
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="22">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="23">
          <Properties>
            <string name="Name">testez</string>
          </Properties>
          <Item class="ModuleScript" referent="24">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/testez@^0.3.1-ts.6",
	_id = "@rbxts/testez@0.3.1-ts.6",
	_inBundle = false,
	_integrity = "sha512-WiiRmYF1bvq4rgiXpzAgvgajZ+Iq49b+d0ki+WrqflUMuDTpUfBduqEWg1bS5t1KAZ22OHfH2pjeqwXwlaif8w==",
	_location = "/@rbxts/testez",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2ftestez",
		fetchSpec = "^0.3.1-ts.6",
		name = "@rbxts/testez",
		raw = "@rbxts/testez@^0.3.1-ts.6",
		rawSpec = "^0.3.1-ts.6",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "range",
	},
	_requiredBy = {"#DEV:/", "#USER"},
	_resolved = "https://registry.npmjs.org/@rbxts/testez/-/testez-0.3.1-ts.6.tgz",
	_shasum = "455c59c9e165164fb4c7d2ceb6a1229541e984f2",
	_spec = "@rbxts/testez@^0.3.1-ts.6",
	_where = "C:\Users\Brooke\Documents\Projects\PlayFab\Refactor",
	author = {
		name = "Roblox",
	},
	bugs = {
		url = "https://github.com/roblox-ts/testez/issues",
	},
	bundleDependencies = false,
	dependencies = {
	},
	deprecated = false,
	description = "A fork of TestEZ with TypeScript typings",
	devDependencies = {
		["@rbxts/types"] = "^1.0.350",
		["@typescript-eslint/eslint-plugin"] = "^2.17.0",
		["@typescript-eslint/parser"] = "^2.17.0",
		eslint = "^6.8.0",
		["eslint-config-prettier"] = "^6.9.0",
		["eslint-plugin-prettier"] = "^3.1.2",
		["eslint-plugin-roblox-ts"] = "0.0.7",
		prettier = "^1.19.1",
	},
	files = {"src", "globals.d.ts"},
	homepage = "https://github.com/roblox-ts/testez#readme",
	keywords = {},
	license = "Apache 2.0",
	main = "src/init.lua",
	name = "@rbxts/testez",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-ts/testez.git",
	},
	scripts = {
	},
	types = "src/index.d.ts",
	version = "0.3.1-ts.6",
}</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="25">
            <Properties>
              <string name="Name">src</string>
              <string name="Source">local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ</string>
            </Properties>
            <Item class="ModuleScript" referent="26">
              <Properties>
                <string name="Name">Context</string>
                <string name="Source"><![CDATA[--[[
	The Context object implements a write-once key-value store. It also allows
	for a new Context object to inherit the entries from an existing one.
]]
local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}
	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="27">
              <Properties>
                <string name="Name">Expectation</string>
                <string name="Source">--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (type(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is truthy
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) &lt;= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called
]]
function Expectation:throw()
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	local message = formatMessage(self.successCondition,
		"Expected function to throw an error, but it did not.",
		("Expected function to succeed, but it threw an error: %s"):format(
			tostring(err)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="28">
              <Properties>
                <string name="Name">LifecycleHooks</string>
                <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)

local LifecycleHooks = {}
LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = {
		_stack = {},
	}
	return setmetatable(self, LifecycleHooks)
end

--[[
	Returns an array of `beforeEach` hooks in FIFO order
]]
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end

--[[
	Returns an array of `afterEach` hooks in FILO order
]]
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end

--[[
	Pushes uncalled beforeAll and afterAll hooks back up the stack
]]
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end

function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)

	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end

--[[
	Get the beforeAll hooks from the current level.
]]
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end

--[[
	Get the afterAll hooks from the current level.
]]
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end

function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></string>
              </Properties>
            </Item>
            <Item class="Folder" referent="29">
              <Properties>
                <string name="Name">Reporters</string>
              </Properties>
              <Item class="ModuleScript" referent="30">
                <Properties>
                  <string name="Name">TeamCityReporter</string>
                  <string name="Source">local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="31">
                <Properties>
                  <string name="Name">TextReporter</string>
                  <string name="Source">--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() &lt; b.planNode.phrase:lower()
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="32">
                <Properties>
                  <string name="Name">TextReporterQuiet</string>
                  <string name="Source">--[[
	Copy of TextReporter that doesn't output successful tests.

	This should be temporary, it's just a workaround to make CI environments
	happy in the short-term.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporterQuiet</string>
                </Properties>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="33">
              <Properties>
                <string name="Name">TestBootstrap</string>
                <string name="Source">--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		-- Use the directory's node for init.spec files.
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end
	table.insert(path, stripSpecSuffix(root.Name))

	return path
end

local function toStringPath(tablePath)
	local stringPath = ""
	local first = true
	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end
	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower()
		})
	end
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter

	otherOptions = otherOptions or {}
	local showTimingInfo = otherOptions["showTimingInfo"] or false
	local testNamePattern = otherOptions["testNamePattern"]
	local extraEnvironment = otherOptions["extraEnvironment"] or {}

	if type(roots) ~= "table" then
		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
	end

	local startTime = tick()

	local modules = {}
	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="34">
              <Properties>
                <string name="Name">TestEnum</string>
                <string name="Source">--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="35">
              <Properties>
                <string name="Name">TestPlan</string>
                <string name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner.
]]

local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
				typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
		node.callback = callback
		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end
		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end

	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end

	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end

	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end

	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end

	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
		warn("FIXME: broken test", node:getFullName())
	end

	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
	local lifecyclePhaseId = 0

	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach"
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		This function is deprecated. Calling it is a no-op beyond generating a
		warning.
	]]
	function env.HACK_NO_XPCALL()
		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
			"xpcall, so this is no longer necessary. It can be safely deleted.")
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP

	env.expect = Expectation.new

	return env
end

local TestNode = {}
TestNode.__index = TestNode

--[[
	Create a new test node. A pointer to the test plan, a phrase to describe it
	and the type of node it is are required. The modifier is optional and will
	be None if left blank.
]]
function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)
	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end
	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase
	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
	child.parent = self
	table.insert(self.children, child)
	return child
end

--[[
	Join the names of all the nodes back to the parent.
]]
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()
		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end
	return self.phrase
end

--[[
	Expand a node by setting its callback environment and then calling it. Any
	further it and describe calls within the callback will be added to the tree.
]]
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })
	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end
	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, debug.traceback)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}
TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end

--[[
	Add a new child under the test plan's root node.
]]
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
	table.insert(self.children, child)
	return child
end

--[[
	Add a new describe node with the given method as a callback. Generates or
	reuses all the describe nodes along the path.
]]
function TestPlan:addRoot(path, method)
	local curNode = self
	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child
				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method
	curNode:expand()
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)

		self:visitAllNodes(callback, child, level + 1)
	end
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize()
	local buffer = {}
	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)
	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback)
	local results = {}
	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)
	return results
end

return TestPlan
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="36">
              <Properties>
                <string name="Name">TestPlanner</string>
                <string name="Source">--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]
local TestPlan = require(script.Parent.TestPlan)

local TestPlanner = {}

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.

	Parameters:
		- modulesList - list of tables describing test modules {
			method, -- specification function described above
			path, -- array of parent entires, first element is the leaf that owns `method`
			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
		}
		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
							function during execution
]]
function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting &lt; b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="37">
              <Properties>
                <string name="Name">TestResults</string>
                <string name="Source">--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if child.messages and #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase or ""
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="38">
              <Properties>
                <string name="Name">TestRunner</string>
                <string name="Source">--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local Expectation = require(script.Parent.Expectation)
local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

function TestRunner.environment.expect(...)
	return Expectation.new(...)
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage
		-- Any code can check RUNNING_GLOBAL to fork behavior based on
		-- whether a test is running. We use this to avoid accessing
		-- protected APIs; it's a workaround that will go away someday.
		_G[RUNNING_GLOBAL] = true

		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. message .. "\n" .. debug.traceback()
		end

		local context = session:getContext()

		local nodeSuccess, nodeResult = xpcall(
			function()
				callback(context)
			end,
			function(message)
				return messagePrefix .. message .. "\n" .. debug.traceback()
			end
		)

		-- If a node threw an error, we prefer to use that message over
		-- one created by fail() if it was set.
		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end

	local function runNode(childPlanNode)
		-- Errors can be set either via `error` propagating upwards or
		-- by a test calling fail([message]).

		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		do
			local success, errorMessage = runCallback(childPlanNode.callback)
			if not success then
				return false, errorMessage
			end
		end

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false
	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
		if not success then
			session:addDummyError("beforeAll", errorMessage)
			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			session:pushNode(childPlanNode)

			if childPlanNode.type == TestEnum.NodeType.It then
				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				-- Did we have an error trying build a test plan?
				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError
					session:setError(message)
				else
					session:setStatusFromChildren()
				end
			end

			session:popNode()
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")
		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="39">
              <Properties>
                <string name="Name">TestSession</string>
                <string name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results
	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)

	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)
	table.insert(self.contextStack, context)
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
end

--[[
	Gets the Context object for the current node.
]]
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
	return self.contextStack[#self.contextStack]
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

--[[
	Set the current node's status to Success.
]]
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end

--[[
	Set the current node's status to Skipped.
]]
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end

--[[
	Set the current node's status to Failure and adds a message to its list of
	errors.
]]
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
	local last = self.nodeStack[#self.nodeStack]
	last.status = TestEnum.TestStatus.Failure
	table.insert(last.errors, message)
end

--[[
	Add a dummy child node to the current node to hold the given error. This
	allows an otherwise empty describe node to report an error in a more natural
	way.
]]
function TestSession:addDummyError(phrase, message)
	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
	self:setError(message)
	self:popNode()
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end

--[[
	Set the current node's status based on that of its children. If all children
	are skipped, mark it as skipped. If any are fails, mark it as failed.
	Otherwise, mark it as success.
]]
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	-- If all children were skipped, then we were skipped
	-- If any child failed, then we failed!
	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="40">
          <Properties>
            <string name="Name">types</string>
          </Properties>
          <Item class="Folder" referent="41">
            <Properties>
              <string name="Name">include</string>
            </Properties>
            <Item class="Folder" referent="42">
              <Properties>
                <string name="Name">generated</string>
              </Properties>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="43">
            <Properties>
              <string name="Name">package</string>
              <string name="Source">return {
	_from = "@rbxts/types",
	_id = "@rbxts/types@1.0.394",
	_inBundle = false,
	_integrity = "sha512-N3RJwd/1aXjBeLTEapYAV59noafLFqql07szK+fDASh70Wr8ye2OWWL8vqlgIRWw0DAwrCBHCXxtRqZdrwVjeg==",
	_location = "/@rbxts/types",
	_phantomChildren = {
	},
	_requested = {
		escapedName = "@rbxts%2ftypes",
		fetchSpec = "latest",
		name = "@rbxts/types",
		raw = "@rbxts/types",
		rawSpec = "",
		registry = true,
		saveSpec = nil,
		scope = "@rbxts",
		type = "tag",
	},
	_requiredBy = {"#DEV:/", "#USER"},
	_resolved = "https://registry.npmjs.org/@rbxts/types/-/types-1.0.394.tgz",
	_shasum = "bb6702feaa07845b0a04bd79a947699a31255f75",
	_spec = "@rbxts/types",
	_where = "C:\Users\Brooke\Documents\Projects\PlayFab\Refactor",
	author = {
		name = "roblox-ts",
	},
	bugs = {
		url = "https://github.com/roblox-ts/types/issues",
	},
	bundleDependencies = false,
	deprecated = false,
	description = "TypeScript typings for the Roblox platform. Partially handwritten and partially automatically generated.",
	homepage = "https://github.com/roblox-ts/types#readme",
	keywords = {"types", "Roblox", "typescript"},
	license = "MIT",
	main = "include/roblox.d.ts",
	name = "@rbxts/types",
	publishConfig = {
		access = "public",
	},
	repository = {
		type = "git",
		url = "git+https://github.com/roblox-ts/types.git",
	},
	scripts = {
	},
	types = "include/roblox.d.ts",
	version = "1.0.394",
}</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>